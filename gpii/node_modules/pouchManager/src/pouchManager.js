/*!
GPII Pouch Manager

Copyright 2016 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

/*
 * Pouch Manager manages the pouchDB that is used as the auth server data storage when GPII runs in the development mode.
 * It also provides an API /reset-pouch to reset the pouchDB to its initial state.
 * Note that /reset-pouch API uses a separate express server from the the pouchDB express server because the reset needs to
 * re-instantiate the entire pouchDB express server rather than re-instantiating the pouch-express middleware because GPII
 * express server has its own way to wire up children middleware. It doesn't make sense to programmatically control the
 * creation/recreation of the middleware.
 *
 * Pouch Manager accepts these options:
 * @authDBServerPort {Integer} The port number that the pouch express server runs upon.
 * @resetServerPort {Integer} The port number that a express server runs upon for resetting the pouch express server runs at the port of @authDBServerPort
 *  to its initial state. Note that a separate server is needed for the reset is because the underlying library "expressPouchdb" used by gpii.pouch.express
 *  implementation is aggressive enough to respond to any http request rooted at the root.
 * @baseDir: {String} The base directory that is used to save pouch data.
 * @pouchConfig {Object} Configuration options to config the pouchDB. Refer to https://github.com/GPII/gpii-pouchdb/blob/master/docs/pouch-component.md on details of accepted options.
 */
fluid.defaults("gpii.pouchManager", {
    gradeNames: ["fluid.component"],
    authDBServerPort: 8058,
    resetServerPort: 8060,
    baseDir: "@expand:{settingsDir}.getSettingsDir()",
    members: {
        recreatePouchHarnessAfterDestroy: false
    },
    components: {
        settingsDir: {
            type: "gpii.settingsDir"
        },
        pouchHarness: {
            type: "gpii.pouch.harness.persistent",
            createOnEvent: "onCreatePouchHarness",
            options: {
                port: "{pouchManager}.options.authDBServerPort",
                baseDir: "{pouchManager}.options.baseDir",
                listeners: {
                    "onReady.escalate": "{pouchManager}.events.onPouchHarnessReady",
                    "afterDestroy.recreatePouchHarness": {
                        listener: "gpii.pouchManager.recreatePouchHarness",
                        args: ["{pouchManager}"]
                    }
                }
            }
        },
        expressReset: {
            type: "gpii.express",
            options: {
                port: "{pouchManager}.options.resetServerPort",
                components: {
                    resetMiddleware: {
                        type: "gpii.pouchManager.resetMiddleware"
                    }
                },
                listeners: {
                    "onStarted.escalate": "{pouchManager}.events.onExpressResetStarted.fire"
                }
            }
        }
    },
    events: {
        onPouchHarnessReady: null,
        onExpressResetStarted: null,
        onReady: {
            events: {
                onPouchHarnessReady: "onPouchHarnessReady",
                onExpressResetStarted: "onExpressResetStarted"
            }
        },
        onCreatePouchHarness: null
    },
    listeners: {
        "onCreate.createPouchHarness": "{that}.events.onCreatePouchHarness.fire"
    },
    distributeOptions: {
        distributePouchConfig: {
            source: "{that}.options.pouchConfig",
            target: "{that gpii.pouch.express}.options"
        },
        distributePouchExpressListeners: {
            record: {
                "onCleanupComplete.destroyPouchHarness": "{pouchHarness}.destroy"
            },
            target: "{that gpii.pouch.express}.options.listeners"
        }
    }
});

gpii.pouchManager.recreatePouchHarness = function (pouchManager) {
    if (pouchManager.recreatePouchHarnessAfterDestroy) {
        pouchManager.events.onCreatePouchHarness.fire();
        pouchManager.recreatePouchHarnessAfterDestroy = false;
    }
};

//*************** Reset pouch middleware and its handler ***************

fluid.defaults("gpii.pouchManager.resetMiddleware", {
    gradeNames: ["gpii.express.middleware.requestAware"],
    path: "/reset-pouch",
    namespace: "resetMiddleware",
    method: "get",
    handlerGrades: ["gpii.pouchManager.reset.handler"]
});

fluid.defaults("gpii.pouchManager.reset.handler", {
    gradeNames: ["gpii.express.handler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.pouchManager.reset.handler.reset",
            args: ["{that}", "{pouchManager}"]
        }
    },
    listeners: {
        "{pouchManager}.events.onPouchHarnessReady": {
            funcName: "{that}.sendResponse",
            args: ["{that}.options.responses.success.statusCode", "{that}.options.responses.success.message"]
        }
    },
    responses: {
        success: {
            statusCode: 200,
            message: "Success: Pouch has been reset to the initial state."
        },
        error: {
            statusCode: 500
        }
    }
});

gpii.pouchManager.reset.handler.reset = function (that, pouchManager) {
    pouchManager.recreatePouchHarnessAfterDestroy = true;
    var cleanupPromise = pouchManager.pouchHarness.express.expressPouch.cleanup();

    // The success call back is unnecessary here, which is substituted by the onCleanupComplete listener.
    cleanupPromise.then(null, function (err) {
        that.sendResponse(that.options.responses.error.statusCode, err);
    });
};
