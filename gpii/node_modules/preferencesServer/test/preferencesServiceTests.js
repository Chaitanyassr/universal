/*!
Copyright 2017-2018 OCAD university

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/
"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    gpii = fluid.registerNamespace("gpii");

require("./preferencesServerTestsUtils.js");
require("./preferencesServerTests.js");

fluid.require("%gpii-universal");
gpii.loadTestingSupport();

fluid.registerNamespace("gpii.tests.preferencesServer.preferencesService");

// All input test data
gpii.tests.preferencesServer.preferencesService.testData = {
    preferencesToCreate: {
        "http://registry.gpii.net/common/matchMakerType": "ruleBased",
        "http://registry.gpii.net/common/fontSize": 24
    },
    preferencesToUpdate: {
        "flat": {
            "contexts": {
                "gpii-default": {
                    "name": "an updated name",
                    "preferences": {
                        "http://registry.gpii.net/common/fontSize": 20
                    }
                }
            }
        },
        "newKey": {
            "nested": "nested-value"
        }
    }
};

// All expected results
gpii.tests.preferencesServer.preferencesService.expected = {
    // for testing getPreferencesByGpiiKey()
    receivedPrefs: {
        "flat": {
            "name": "Default context",
            "contexts": {
                "gpii-default": {
                    "name": "Default preferences",
                    "preferences": {
                        "http://registry.gpii.net/common/matchMakerType": "ruleBased",
                        "http://registry.gpii.net/common/fontSize": 24,
                        "http://registry.gpii.net/common/foregroundColor": "white"
                    }
                }
            }
        }
    },
    updatedPrefs: {
        "flat": {
            "name": "Default context",
            "contexts": {
                "gpii-default": {
                    "name": "an updated name",
                    "preferences": {
                        "http://registry.gpii.net/common/fontSize": 20,
                        "http://registry.gpii.net/common/foregroundColor": "white",
                        "http://registry.gpii.net/common/matchMakerType": "ruleBased"
                    }
                }
            }
        },
        "newKey": {
            "nested": "nested-value"
        }
    },
    unauthorized: {
        message: "Unauthorized",
        statusCode: 401,
        isError: true
    },
    missingGpiiKey: {
        message: "GPII key \"non-existent-gpii-key\" does not exist"
    },
    noUpdateOnSnapset: {
        message: "Cannot update:  GPII key \"snapset1\" is a snapset"
    },
    // for testing createPreferences()
    preferencesToCreate_prefsOnly: {
        prefsSafeType: "user",
        name: null,
        password: null,
        email: null,
        preferences: {
            "http://registry.gpii.net/common/cursorSize": 24
        }
    },
    gpiiKeyExisted: "GPII key \"alice_gpii_key\" already exists"
};

/**
 * Utility for calling the preferences service duing the test sequences.
 *
 * Calls an invoker on the `preferencesService` that returns a promise.
 * If only the first 2 arguments are used, this function returns the
 * actual promise. If an event is provided as the optional third argument,
 * that event is fired using the promises resolve data, and nothing
 * is returned from the function.
 *
 * It's interesting to note in the tests below, that if the argument
 * provided to a `task` is an IoC preference to the `{preferencesService}`
 * that it is injected as `undefined`. This may be due to the order of test
 * creation. ie. These bootstrap tests are perhaps wired before the
 * preferences service is created for each test. This is partially the
 * reason for this function, but also because we do need the option to just
 * fire the event in order to sequence some of the listeners between tasks.
 *
 * ie:
 * task: "gpii.tests.preferencesServer.preferencesService.fetch",
 *       args: ["{preferencesService}.getPreferencesByGpiiKey", "alice_gpii_key"],
 *       // The first argument will be undefined.
 *
 * @param {String} prefsServiceInvoker - Name of the invoker to call on the preferences service.
 * @param {Array} args - List of arguments to pass to the invoker.
 * @param {Event} eventToFire - Optional. Event to be fired with promise resolve data if
 * supplied.
 * @return {fluid.promise|undefined} If an event to fire is not included this function
 * returns the promise from the preferences service. If an event is provided this function
 * returns nothing, but fires the event with the resolved data.
 */
gpii.tests.preferencesServer.preferencesService.promise = function (prefsServiceInvoker, args, eventToFire) {
    var prefsService = fluid.queryIoCSelector(fluid.rootComponent, "gpii.preferencesServer.preferencesService")[0];
    var promTogo = prefsService[prefsServiceInvoker].apply(null, args);
    if (eventToFire) {
        promTogo.then(function (data) {
            eventToFire.fire(data);
        }, function (err) {
            eventToFire.fire(err);
        });
    }
    else {
        return promTogo;
    }
};

// The pouchTestCaseHolder for the preferences server that loads specific data files
// These tests use their own sets of users in `preferencesServiceUsers.json`
fluid.defaults("gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder", {
    gradeNames: ["gpii.test.pouch.pouchTestCaseHolder"],
    mergePolicy: {
        "pouchConfig.databases.gpii.data": "replace"
    },
    pouchConfig: {
        databases: {
            gpii: {
                data: [
                    "%preferencesServer/test/data/gpiiKeys.json",
                    "%preferencesServer/test/data/gpiiCloudSafeCred.json",
                    "%preferencesServer/test/data/userLookup.json",
                    "%preferencesServer/test/data/preferencesServiceUsers.json",
                    "%gpii-universal/testData/dbData/views.json"
                ]
            }
        }
    }
});

gpii.tests.preferencesServer.preferencesService.getPreferencesByGpiiKey = [
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "getPreferencesByGpiiKey() returns preferences - a successful workflow",
        expect: 1,
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPreferencesByGpiiKey", ["alice_gpii_key"]],
            resolve: "jqUnit.assertDeepEq",
            resolveArgs: ["The access token should be received in an expected format", gpii.tests.preferencesServer.preferencesService.expected.receivedPrefs, "{arguments}.0"]
        }]
    }, {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        expect: 1,
        name: "getPreferencesByGpiiKey() returns undefined when the GPII key has no preferences defined",
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPreferencesByGpiiKey", ["bob_gpii_key"]],
            resolve: "jqUnit.assertUndefined",
            resolveArgs: ["undefined is returned when the gpii key has no preferences defined", "{arguments}.0"]
        }]
    },  {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        expect: 1,
        name: "getPreferencesByGpiiKey() returns error when a gpii key is not provided in the argument list",
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPreferencesByGpiiKey", ["non-existent-gpii-key"]],
            reject: "jqUnit.assertDeepEq",
            rejectArgs: ["The error is returned when a gpii key is not found", gpii.tests.preferencesServer.preferencesService.expected.missingGpiiKey, "{arguments}.0"]
        }]
    }
];

gpii.test.bootstrapServer(gpii.tests.preferencesServer.preferencesService.getPreferencesByGpiiKey);

gpii.tests.preferencesServer.preferencesService.createPreferences = [
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "createPreferences() creates a prefs safe and an auto generated GPII key - a successful workflow",
        events: {
            onFinishedCreate: null,
            onFinishedLookup: null
        },
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["createPreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate]],
            resolve: "{that}.events.onFinishedCreate.fire",
            resolveArgs: ["{arguments}.0"]
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPrefsSafeByGpiiKey", ["{arguments}.0.gpiiKey"], "{that}.events.onFinishedLookup"],
            event: "{that}.events.onFinishedCreate"
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe",
            args: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "{arguments}.0"],
            event: "{that}.events.onFinishedLookup"
        }]
    },
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "createPreferences() creates a prefs safe and an GPII key with the provided key value - a successful workflow",
        events: {
            onFinishedCreate: null,
            onFinishedLookup: null
        },
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["createPreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "a-new-gpii-key-by-preferences-service"]],
            resolve: "{that}.events.onFinishedCreate.fire",
            resolveArgs: ["{arguments}.0"]
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPrefsSafeByGpiiKey", ["{arguments}.0.gpiiKey"], "{that}.events.onFinishedLookup"],
            event: "{that}.events.onFinishedCreate"
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe",
            args: [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "{arguments}.0", "a-new-gpii-key-by-preferences-service"],
            event: "{that}.events.onFinishedLookup"
        }]
    },
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "createPreferences() returns error when the provided GPII key already exists",
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["createPreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToCreate, "alice_gpii_key"]],
            reject: "jqUnit.assertDeepEq",
            rejectArgs: ["The error is returned when the provided GPII key already exists", gpii.tests.preferencesServer.preferencesService.expected.gpiiKeyExisted, "{arguments}.0"]
        }]
    }
];

gpii.test.bootstrapServer(gpii.tests.preferencesServer.preferencesService.createPreferences);

gpii.tests.preferencesServer.preferencesService.verifyFetchedPrefsSafe = function (preferencesToCreate, response, expectedGpiiKey) {
    if (expectedGpiiKey) {
        jqUnit.assertEquals("The created GPII key matches the input GPII key", expectedGpiiKey, response.gpiiKey);
        jqUnit.assertEquals("The GPII key in the key record matches the input GPII key", expectedGpiiKey, response.gpiiKeyDetails.id);
    } else {
        jqUnit.assertNotUndefined("The GPII key is auto generated", response.gpiiKey);
    }

    var gpiiKeyDetails = response.gpiiKeyDetails;
    jqUnit.assertEquals("The value of \"schemaVersion\" has been set correctly", gpii.dbOperation.schemaVersion, gpiiKeyDetails.schemaVersion);
    jqUnit.assertNotUndefined("The value of \"prefsSafeId\" has been set to default", gpiiKeyDetails.prefsSafeId);
    jqUnit.assertEquals("The value of \"prefsSetId\" has been set to default", gpii.preferencesServer.defaultprefsSetId, gpiiKeyDetails.prefsSetId);
    jqUnit.assertFalse("The value of \"revoked\" has been set to false", gpiiKeyDetails.revoked);
    jqUnit.assertNull("The value of \"revokedReason\" has been set to null", gpiiKeyDetails.revokedReason);
    jqUnit.assertNotUndefined("The value of \"timestampCreated\" has been set", gpiiKeyDetails.timestampCreated);
    jqUnit.assertNull("The value of \"timestampUpdated\" has been set", gpiiKeyDetails.timestampUpdated);

    var prefsSafe = response.prefsSafe;
    jqUnit.assertLeftHand("The data is saved successfully", preferencesToCreate, prefsSafe.preferences);
};

gpii.tests.preferencesServer.preferencesService.updatePreferences = [
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "updatePreferences() updates the associated prefs safe with merged preferences - a successful workflow",
        events: {
            onFetchUpdatedPrefs: null
        },
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPrefsSafeByGpiiKey", ["alice_gpii_key"]],
            // save the original GPII key and prefs safe records to compare after the update
            resolve: "fluid.set",
            resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
        }, {
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key", true]],
            resolve: "gpii.tests.preferencesServer.preferencesService.promise",
            resolveArgs: ["getPrefsSafeByGpiiKey", ["{arguments}.0.gpiiKey"], "{that}.events.onFetchUpdatedPrefs"]
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe",
            args: ["{that}", gpii.tests.preferencesServer.preferencesService.expected.updatedPrefs, "alice_gpii_key", "{arguments}.0"],
            event: "{that}.events.onFetchUpdatedPrefs"
        }]
    },
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "updatePreferences() updates the associated prefs safe without merging with existing preferences - a successful workflow",
        events: {
            onFetchUpdatedPrefs: null
        },
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPrefsSafeByGpiiKey", ["alice_gpii_key"]],
            resolve: "fluid.set",
            resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
        }, {
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key"]],
            resolve: "gpii.tests.preferencesServer.preferencesService.promise",
            resolveArgs: ["getPrefsSafeByGpiiKey", ["{arguments}.0.gpiiKey"], "{that}.events.onFetchUpdatedPrefs"]
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe",
            args: ["{that}", gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "alice_gpii_key", "{arguments}.0"],
            event: "{that}.events.onFetchUpdatedPrefs"
        }]
    },
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "updatePreferences() creates a new prefs safe when the GPII key is not associates with a prefs safe - a successful workflow",
        events: {
            onFetchUpdatedPrefs: null
        },
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["getPrefsSafeByGpiiKey", ["bob_gpii_key"]],
            resolve: "fluid.set",
            resolveArgs: ["{that}", ["originalData"], "{arguments}.0"]
        }, {
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "bob_gpii_key"]],
            resolve: "gpii.tests.preferencesServer.preferencesService.promise",
            resolveArgs: ["getPrefsSafeByGpiiKey", ["{arguments}.0.gpiiKey"], "{that}.events.onFetchUpdatedPrefs"]
        }, {
            listener: "gpii.tests.preferencesServer.preferencesService.verifyNewPrefsSafeForUpdate",
            args: ["{that}", gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "bob_gpii_key", "{arguments}.0"],
            event: "{that}.events.onFetchUpdatedPrefs"
        }]
    },
    {
        config: {
            configName: "gpii.tests.preferencesServer.config",
            configPath: "%preferencesServer/test/configs"
        },
        pouchTestCaseHolder: "gpii.tests.preferencesServer.preferencesService.pouchTestCaseHolder",
        name: "updatePreferences() returns error when updating a snapset",
        sequence: [{
            task: "gpii.tests.preferencesServer.preferencesService.promise",
            args: ["updatePreferences", [gpii.tests.preferencesServer.preferencesService.testData.preferencesToUpdate, "snapset1"]],
            reject: "jqUnit.assertDeepEq",
            rejectArgs: ["The error is returned when updating a snapset", gpii.tests.preferencesServer.preferencesService.expected.noUpdateOnSnapset, "{arguments}.0"]
        }]
    }
];

gpii.test.bootstrapServer(gpii.tests.preferencesServer.preferencesService.updatePreferences);

gpii.tests.preferencesServer.preferencesService.verifyUpdatedPrefsSafe = function (that, updatedPreferences, gpiiKey, response) {
    jqUnit.assertDeepEq("The GPII key in the response is expected", gpiiKey, response.gpiiKey);
    jqUnit.assertDeepEq("The GPII key record is unchanged", that.originalData.gpiiKeyDetails, response.gpiiKeyDetails);
    jqUnit.assertDeepEq("The preferences has been updated", updatedPreferences, response.prefsSafe.preferences);
    jqUnit.assertNotEquals("The prefs safe timestampUpdated has been updated", that.originalData.prefsSafe.timestampUpdated, response.prefsSafe.timestampUpdated);

    var unchangedOrigPrefsSafeFields = fluid.censorKeys(that.originalData.prefsSafe, ["preferences", "timestampUpdated"]);
    var unchangedPrefsSafeFields = fluid.censorKeys(response.prefsSafe, ["preferences", "timestampUpdated"]);
    jqUnit.assertDeepEq("Other prefs safe values are unchanged", unchangedOrigPrefsSafeFields, unchangedPrefsSafeFields);
};

gpii.tests.preferencesServer.preferencesService.verifyNewPrefsSafeForUpdate = function (that, updatedPreferences, gpiiKey, response) {
    // verify before update status
    jqUnit.assertNull("The GPII key originally has no prefs safe associated", that.originalData.gpiiKeyDetails.prefsSafeId);

    // verify after update status
    jqUnit.assertDeepEq("The GPII key in the response is expected", gpiiKey, response.gpiiKey);
    jqUnit.assertNotUndefined("A prefs safe has been created", response.prefsSafe);
    jqUnit.assertNull("The timestampUpdated of the prefs safe is null", response.prefsSafe.timestampUpdated);
    jqUnit.assertDeepEq("The preferences in the prefs safe is expected", updatedPreferences, response.prefsSafe.preferences);
    jqUnit.assertEquals("The prefs safe has been associated with the GPII key", response.gpiiKeyDetails.prefsSafeId, response.prefsSafe.id);

    var unchangedOrigGpiiKeyFields = fluid.censorKeys(that.originalData.gpiiKeyDetails, ["prefsSafeId", "prefsSetId", "timestampUpdated"]);
    var unchangedGpiiKeyFields = fluid.censorKeys(response.gpiiKeyDetails, ["prefsSafeId", "prefsSetId", "timestampUpdated"]);
    jqUnit.assertDeepEq("Other GPII key values are unchanged", unchangedOrigGpiiKeyFields, unchangedGpiiKeyFields);
};
