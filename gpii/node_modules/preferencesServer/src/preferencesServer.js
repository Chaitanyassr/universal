/*!
GPII Preferences Server

Copyright 2012-2016 OCAD University
Copyright 2014-2015 Raising The Floor - International
Copyright 2017-2018 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("ontologyHandler");
require("gpii-oauth2");

fluid.defaults("gpii.preferencesServer", {
    gradeNames: ["fluid.component"],
    requestHandlers: {
        preferencesGet: {
            route: "/preferences/:gpiiKey",
            method: "get",
            type: "gpii.preferencesServer.get.handler"
        },
        preferencesPost: {
            route: "/preferences",
            method: "post",
            type: "gpii.preferencesServer.post.handler"
        },
        preferencesPut: {
            route: "/preferences/:gpiiKey",
            method: "put",
            type: "gpii.preferencesServer.put.handler"
        }
    },
    invokers: {
        getPreferences: {
            funcName: "gpii.preferencesServer.getPreferences",
            args: ["{preferencesService}", "{ontologyHandler}", "{arguments}.0", "@expand:gpii.preferencesServer.getView({arguments}.1)"]
            // gpiiKey, toView
        },
        createPreferences: {
            funcName: "gpii.preferencesServer.createPreferences",
            args: ["{preferencesService}", "{ontologyHandler}", "{arguments}.0", "@expand:gpii.preferencesServer.getView({arguments}.1)"]
            // preferences, toView
        },
        updatePreferences: {
            funcName: "gpii.preferencesServer.updatePreferences",
            args: ["{preferencesService}", "{ontologyHandler}", "{arguments}.0", "{arguments}.1", "@expand:gpii.preferencesServer.getView({arguments}.2)"]
            // gpiiKey, preferences, toView
        // },
        // setRawPreferences: {
        //     funcName: "gpii.preferencesServer.setRawPreferences",
        //     // TODO: This should really return a promise - {arguments}.0 is "onSuccess"
        //     args: ["{gpii.preferencesServer}.preferencesService", "{kettle.request}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
        // },
        // setPrefsRequestHandler: {
        //     funcName: "gpii.preferencesServer.setPrefsRequestHandler",
        //     args: ["{preferencesServer}", "{arguments}.0", "{arguments}.1"]
        //     // request, successEvent
        // },
        // setPrefsReturnHandler: {
        //     funcName: "gpii.preferencesServer.setPrefsReturnHandler",
        //     args: ["{arguments}.0", "{arguments}.1"]
        //     // reply, request
        }
    },
    components: {
        preferencesService: {
            type: "gpii.preferencesServer.preferencesService"
        },
        // rawPreferencesServer: {
        //     type: "kettle.dataSource.URL",
        //     options: {
        //         // url: "{gpii.preferencesServer}.options.urls.rawPreferences",
        //         termMap: {
        //             gpiiKey: "%gpiiKey"
        //         },
        //         writable: true
        //     }
        // },
        ontologyHandler: {
            type: "gpii.ontologyHandler"
        },
        dataStore: {
            type: "gpii.dbOperation.dbDataStore"
        },
        authGrantFinder: {
            type: "gpii.oauth2.authGrantFinder"
        }
    },
    distributeOptions: {
        authorizationServiceDataStore: {
            "record": "{gpii.preferencesServer}.dataStore",
            "target": "{that authorizationService}.options.components.dataStore"
        },
        preferencesServiceDataStore: {
            "record": "{gpii.preferencesServer}.dataStore",
            "target": "{that preferencesService}.options.components.dataStore"
        }
    }
});

/*
 * Simple function to get the 'view'. In case none is given, defaults to the "flat" ontology.
 * @param view {String} a view
 * @return (String) the value of the 'view', or "flat" if none is given
 */
gpii.preferencesServer.getView = function (view) {
    return view ? view : "flat";
};

/**
 * The API to get preferences. Note that this API returns the entire value of the prefsSafe.preferences
 * rather than the particular prefs set that is associated with the GPII key provided as an argument.
 * @param preferencesService {Component} An instance of gpii.preferencesServer.preferencesService
 * @param ontologyHandler {Component} An instance of gpii.ontologyHandler
 * @param gpiiKey {String} An GPII key
 * @param toView {String} An view that the preferences should be transformed upon
 * @return {Promise} A promise object whose resolved value is the preferences transformed based on the view
 */
gpii.preferencesServer.getPreferences = function (preferencesService, ontologyHandler, gpiiKey, toView) {
    var rawPrefsPromise = preferencesService.getPreferencesByGpiiKey(gpiiKey);
    var mapper = function (rawPrefs) {
        var prefs = rawPrefs ? ontologyHandler.rawPrefsToOntology(rawPrefs, toView) : undefined;
        fluid.log("Preferences Server, getPreferences(), returning preferences: ", prefs);
        return prefs;
    };
    return fluid.promise.map(rawPrefsPromise, mapper);
};

/**
 * The API to create preferences. This API does:
 * 1. Create a GPII key and a new prefs safe with the given preferences. Also associates the prefs safe with the GPII key;
 * 2. If preferences is not provided, reject with an error.
 * @param preferencesService {Component} An instance of gpii.preferencesServer.preferencesService
 * @param ontologyHandler {Component} An instance of gpii.ontologyHandler
 * @param preferences {Object} A preferences object
 * @param toView {String} An view that the provided preferences is based upon
 * @return {Promise} A promise object whose resolved value is:
 * {
 *     gpiiKey: {String},
 *     preferences: {Object}
 * }
 */
gpii.preferencesServer.createPreferences = function (preferencesService, ontologyHandler, preferences, toView) {
    var promiseTogo = fluid.promise();
    if (!preferences) {
        // preferences must be provided
        fluid.log("Preferences Server, createPreferences(), adding preferences, rejected due to missing preferences");
        promiseTogo.reject({
            "message": gpii.preferencesServer.errors.missingPreferences
        });
    } else {
        var payload = {};
        payload[toView] = preferences;

        fluid.log("Preferences Server, createPreferences(), adding preferences: ", payload);
        promiseTogo = preferencesService.createPreferences({
            preferences: payload
        });
    }
    return promiseTogo;
};

/**
 * The API to update an existing preferences safe to the Preferences Server. This API does:
 * 1. If the GPII key exists and associates with a prefs safe, update the prefs safe with the new preferences;
 * 2. If the GPII key exists but not associates with a prefs safe, create a new prefs safe with the preferences and associate it with the GPII key;
 * 3. If the GPII key does not exist in the db, reject with an error;
 * 4. If the GPII key or the preferences value is not provided, reject with an error.
 * @param that {Component} An instance of gpii.preferencesServer
 * @param gpiiKey {String} A GPII key
 * @param preferences {Object} A preferences object
 * @param toView {String} An view that the provided preferences is based upon
 * @return {Promise} A promise object whose resolved value is:
 * {
 *     gpiiKey: {String},
 *     preferences: {Object}
 * }
 */
gpii.preferencesServer.updatePreferences = function (preferencesService, ontologyHandler, gpiiKey, preferences, toView) {
    var promiseTogo = fluid.promise();
    if (!gpiiKey) {
        // GPII key must be provided
        fluid.log("Preferences Server, updatePreferences(), updating preferences, rejected due to missing GPII key");
        promiseTogo.reject({
            "message": gpii.preferencesServer.errors.missingGpiiKey
        });
    } else if (!preferences) {
        // preferences must be provided
        fluid.log("Preferences Server, updatePreferences(), updating preferences, rejected due to missing preferences");
        promiseTogo.reject({
            "message": gpii.preferencesServer.errors.missingPreferences
        });
    } else {
        var gpiiKeyPromise = preferencesService.getPrefsSafeByGpiiKey(gpiiKey);

        gpiiKeyPromise.then(function (gpiiKeyRelatedData) {
            var preferencesPromise = fluid.promise();
            var payload;
            if (gpiiKeyRelatedData) {
                // If the GPII key exists:
                // 1. If an existing prefs safe already associates with the GPII key, update the prefs safe;
                // 2. If no prefs safe is associated with the GPII key, create the prefs safe and associate with the GPII key.
                var rawPrefs = fluid.get(gpiiKeyRelatedData, ["prefsSafe", "preferences"]);
                payload = ontologyHandler.addPrefsToRawPrefs(preferences, toView, rawPrefs || {});
                preferencesPromise = preferencesService.updatePreferences({
                    preferences: payload
                }, gpiiKey, rawPrefs ? false : true);
            } else {
                // If the GPII key does not exist, create it
                payload = {};
                payload[toView] = preferences;

                preferencesPromise = preferencesService.createPreferences({
                    preferences: payload
                }, gpiiKey);
            }
            fluid.promise.follow(preferencesPromise, promiseTogo);
        });
    }
    return promiseTogo;
};

gpii.preferencesServer.setRawPreferences = function (preferencesService, request, successEvent, body, gpiiKey) {
    // if we were passed a GPII key, that means we want to do an update, else we're creating a new NP set
    var writeMethod = (gpiiKey) ? "PUT" : "POST";
    var promise = preferencesService.set({gpiiKey: gpiiKey || ""}, body, {writeMethod: writeMethod});
    promise.then(successEvent.fire, request.events.onError.fire);
};

// TODO - should be removed or factored - just copied from gpii.flowmanager.logAndNotify
gpii.preferencesServer.logAndNotify = function (msg, event, callback) {
    return function (data) {
        fluid.log(msg, data);
        event.fire(callback ? callback(data) : data);
    };
};

gpii.preferencesServer.setPrefsRequestHandler = function (preferencesServer, request, successEvent) {
    // key preferences set by ontology
    var toView = gpii.preferencesServer.getView(request);
    var payload = {};
    payload[toView] = request.req.body;
    preferencesServer.setRawPreferences(successEvent, payload, undefined);
};

gpii.preferencesServer.setPrefsReturnHandler = function (reply, request) {
    // despite potentially having modified the entire raw preferences set, we only return the
    // preferences in the view that we originally got them
    var ret = {
        gpiiKey: reply.gpiiKey,
        preferences: reply.preferences[gpii.preferencesServer.getView(request)]
    };
    request.events.onSuccess.fire(ret);
};
