/*
* Context Manager
*
* Copyright 2014-2017 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.contextManager", {
    gradeNames: "fluid.modelComponent",
    invokers: {
        updateActiveContextName: {
            funcName: "gpii.contextManager.updateActiveContextName",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                             // fullPayload, forceContextName
        },
        contextChanged: {
            funcName: "gpii.contextManager.contextChanged",
            args: ["{that}", "{lifecycleManager}", "{arguments}.0"]
                                                   // forceContextName
        },
        updateCurrentContext: "gpii.contextManager.updateCurrentContext({that}, {arguments}.0)"
                                                                                // context name, e.g. "bright"
    },
    modelListeners: {
        currentContext: {
            func: "{that}.contextChanged",
            args: []
        }
    }
});

/**
 * Store the new context name.
 *
 * @param {Component} that - The context manager component
 * @param {Sting} newContext - New context name
 **/
gpii.contextManager.updateCurrentContext = function (that, newContext) {
    fluid.log("contextManager: Updating environment with: '" + newContext + "'");
    that.applier.change("currentContext", newContext);
};

/**
 * On changes to the context:
 * 1) parse the context against the currently logged in user's conditions
 * 2) if the new calculated active context is different from the currently applied context,
 *    the LifecycleManager's update functionality will be called and the applied context and
 *    configuration will be stored in the active session of the lifecycle manager.
 *
 * @param {Object} that - The context manager object
 * @param {Component} lifecycleManager - The lifecycleManager component from which the current
 *    session will be retrieved
 * @param {String} [forceContextName] - [optional] A context name to be unconditionally selected
 * @return {Promise} If the context change causes an actual change in the system (i.e. change of
 *    active context and changes to the applied configuration) a promise of an update to the system
 *    configuration is returned. If the call to contextChanged does not result in a different
 *    active context or no user is logged in, undefined will be returned.
 **/
gpii.contextManager.contextChanged = function (that, lifecycleManager, forceContextName) {
    // find logged in users
    var activeSession = lifecycleManager.getSession();
    var activeGpiiKey = activeSession.model.gpiiKey;

    // if no one is logged in, or, a system reserved key is logged in, do nothing
    if (!activeGpiiKey || gpii.isReservedGpiiKey(activeGpiiKey)) {
        return;
    }
    var fullPayload = fluid.extend(true, {}, activeSession.model);
    var oldActiveContext = fullPayload.activeContextName;

    // find and update context:
    that.updateActiveContextName(fullPayload, forceContextName);

    if (oldActiveContext === fullPayload.activeContextName) {
        fluid.log(fluid.logLevel.TRACE, "contextManager: Same context as before (" + oldActiveContext + ") so doing nothing");
        return;
    }
    fluid.log("contextManager: Context changed from old context \"", oldActiveContext, "\" to new active context \"" + fullPayload.activeContextName, "\" for the GPII key: ", activeGpiiKey);
    // Update the context name immediately so we don't produce a model update from the lifecycleManager with a
    // partially applied set of solutions from the new context, confusing, e.g., the PSPChannel
    // This is required because of https://issues.fluidproject.org/browse/FLUID-6208
    activeSession.applier.change("activeContextName", fullPayload.activeContextName);

    // Delete the old appliedSolutions as the new structure will be updated directly onto activeSession.model
    // by lifecycleManager.update() called 2 lines later
    delete fullPayload.appliedSolutions;

    lifecycleManager.addLifecycleInstructionsToPayload(fullPayload);
    var response = lifecycleManager.update(fullPayload);

    response.then(function () {
        // Delete these this to avoid the 'lifecycleInstructions' block being attached
        // to the sessionState in the next line. LifecycleInstructions is only used in the
        // "finalPayload" as instructions on how to configure the system. once configured,
        // the applied settings are stored in 'activeConfiguration'
        delete fullPayload.lifecycleInstructions;
        // TODO: This is pretty rubbish, why isn't the natural action of lifecycleManager.update good enough here?
        activeSession.applier.change("", fullPayload); // TODO: this will need to be a "MERGE" in time
        fluid.log("contextManager: Successfully updated configuration triggered by context changes");
    }, function () {
        fluid.log(fluid.logLevel.FAIL, "contextManager: Failed to apply newly evaluated conditions");
    });
    return response;
};

/**
 * Function to add the current context to the full payload which is output from the matchmaking process.
 *
 * @param {Component} that - An instance of gpii.contextManager component
 * @param {Object} fullPayload - The full structure output from the matchmaking process. NOTE: This object will be modified
 * @param {String} [forceContextName] - [optional] A context name to be selected, overriding environment conditions
 * @return {Object} The modified fullPayload, now including activeContextName, activeConfiguration
 */
gpii.contextManager.updateActiveContextName = function (that, fullPayload, forceContextName) {
    var newActiveContextName = "gpii-default";
    if (forceContextName === undefined) {
        if (fullPayload.forcedContext) { // Don't use stored context if context has been forced
            newActiveContextName = fullPayload.activeContextName;
        } else {
            // TODO:  not certain this code or the model is needed.
            if (that.model && that.model.currentContext) {
                newActiveContextName = that.model.currentContext;
            }
        }
    } else {
        newActiveContextName = forceContextName;
        fullPayload.forcedContext = true;
    }
    fullPayload.activeContextName = newActiveContextName;
    return fullPayload;
};
