/*
 * INI File reader/writer
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

var fs = require("fs"),
    os = require("os"),
    XRegExp = require("xregexp");

gpii.iniFile = fluid.registerNamespace("gpii.iniFile");

var patten = fs.readFileSync(__dirname  + "/ini.regex");
gpii.iniFile.regex = new XRegExp(patten, "gmsx");

/**
 * Parse an INI file, invoking call backs at interesting points: start/end of a section, and on a key=value.
 *
 * If options.write=true, the return values of the callbacks will be used to modify the content, the entirety of which
 * is then returned by this function.
 *
 * It uses the regular expression in ./ini.regex to perform the actual parsing.
 *
 * @param {String} content The INI file content.
 * @param {Object} handlers Object containing the callbacks.
 * @param {Function} handlers.sectionBegin(sectionPath) - called at the start of a new section, returning a string to
 *  write before the section line, if options.write=true.
 * @param {Function} handlers.sectionEnd(sectionPath) - called at the end of a section, after all of its sub-sections
 *  have been seen. Returning a string to write at the end of the section, if options.write=true.
 * @param {Function} handlers.gotValue(sectionPath, key, value, quoted) - called when a value has been parsed. If
 *  options.write=true, return the text to replace the content of the value, undefined for no update, or fluid.NO_VALUE
 *  to remove the key=value pair.
 * @param {Object} options Parser options.
 * @param {Boolean} options.write True if writing.
 * @return {Object|String} The data from the INI file, or the new file content if options.write=true.
 */
gpii.iniFile.parse = function (content, handlers, options) {
    options = Object.assign({}, options);

    var sectionPath = [];

    if (handlers.sectionBegin) {
        handlers.sectionBegin(sectionPath);
    }

    // Called when a [section] has ended, either due to the start of another section, or at the end of file.
    var endSection = function (depth) {
        var result = "";
        // Go back up the stack (if required)
        while (depth <= sectionPath.length) {
            // At this point, the sub-sections for the current section are done.
            if (handlers.sectionEnd) {
                var endContent = handlers.sectionEnd(sectionPath);
                if (options.write && endContent) {
                    result += endContent;
                }
            }
            if (sectionPath.length === 0) {
                break;
            }
            sectionPath.pop();
        }
        return result;
    };

    var regexFunction = options.write ? XRegExp.replace : XRegExp.forEach;

    var output = regexFunction(content, gpii.iniFile.regex, function (match) {
        var result = options.write && match.toString();
        if (match.section) {
            // The number of ['s in the section line.
            var depth = match.sectionCount.length;

            if (depth > sectionPath.length + 1) {
                fluid.log("INI file parse error: Current section is not a direct descendant of the previous section");
            }

            var endContent = endSection(depth);
            if (options.write) {
                result = endContent + result;
            }

            sectionPath.push(match.section);

            if (handlers.sectionBegin) {
                var prepend = handlers.sectionBegin(sectionPath);
                if (options.write && prepend) {
                    result = prepend + result;
                }
            }

        } else {
            // It's some type of key=value pair.
            var value = fluid.find(
                [match.value, match.value_ml_indent, match.value_ml_quote, match.value_quote], fluid.identity);

            if (match.value_quote) {
                value = value.replace("\\\"", "\"");
            } else if (match.value_ml_indent || match.value_ml_quote) {
                value = value.replace(/\n[^\S\n]+/g, "\n");
            }

            if (handlers.gotValue) {
                var quoted = match.value_ml_quote !== undefined || match.value_quote !== undefined;
                var newValue = handlers.gotValue(sectionPath, match.key, value, quoted);
                if (options.write) {
                    if (newValue === fluid.NO_VALUE) {
                        result = "";
                    } else if (newValue !== undefined) {
                        var quote = (match.qqq || match.q || "");
                        if (match.value_ml_indent) {
                            newValue = newValue.replace(/\n/g, "\n" + match.indent + " ".repeat(4));
                        }
                        result = match.prefix + quote + newValue + quote + match.suffix;
                    }
                }
            }
        }

        return result;
    });

    var append = endSection(0);
    if (options.write && append) {
        output += append;
    }

    return options.write && output;
};

/**
 * Writes an object to existing INI file content.
 *
 * @param {String} input The ini file content to update (can be empty).
 * @param {Object} data The new settings data.
 * @param {Object} options Options, mostly for writing new values.
 * @param {String} options.keyValueDelimiter - Text which separates keys and values, for new values. [default: "="].
 * @param {Boolean} options.keepUndefined - true to keep items and sections that are not in data. Use to define values
 * without reading the file beforehand.
 * @param {String} options.multilineStyle - How new multi-line values are written:
 *   "'''" or '"""': Surround the value with 3x single or double quotes (default).
 *   "indent": Indent the additional lines.
 *   "escape": Use an escaped n (\n).
 *   anything else: Wrap the value with the given value.
 * @param {String} options.quote - For new values, quote them "always", "never", "strings" (for only strings), or
 *  "spaces" (if the value starts or ends with a space) [default: "spaces"].
 * @param {String} options.quoteChar - The quote character for new values when quoting. [default: " (double quote)].
 * @param {String} options.eol - The file's end of line character(s). [default: auto-detect]
 *
 * @return {String} The new ini file content.
 */
gpii.iniFile.write = function (input, data, options) {
    options = Object.assign({
        keyValueDelimiter: "=",
        keepUndefined: false,
        eol: undefined,
        quoteChar: "\"",
        quote: "spaces",
        multilineStyle: "\"\"\""
    }, options);

    if (options.eol === undefined) {
        var m = /\r\n|[\r\n]/.exec(input);
        options.eol = m && m[0] || os.EOL;
    }

    options.write = true;

    /**
     * Stringify a value - converts it to a string as returned by JSON.stringify.
     * @param {Mixed} value The value.
     * @return {String} The stringified version of value.
     */
    var stringify = function (value) {
        if (value === null || value === undefined) {
            return "";
        } else {
            return typeof(value) === "string" ? value : JSON.stringify(value);
        }
    };

    /**
     * Generates the text of a new key=value pair, or a new section and it's values and sub-sections if value is an
     * object.
     * @param {String} key The name of it.
     * @param {String|Number|Boolean} value The value.
     * @param {Array<String>} path The path of the containing section.
     * @return {Array<String>} Array of lines for the new value or sub-section.
     */
    var writeValue = function (key, value, path) {
        var output = [];
        if (fluid.isPlainObject(value)) {
            // The section header.
            output.push("");
            output.push("[".repeat(path.length + 1) + key + "]".repeat(path.length + 1));
            // Section items.
            fluid.each(Object.keys(value), function (subkey) {
                output.push.apply(output, writeValue(subkey, value[subkey], path.concat(key)));
            });
        } else {
            var newValue = stringify(value);

            if (newValue.indexOf("\n") >= 0) {
                // A multi-line value.
                switch (options.multilineStyle) {
                case "indent":
                    // eol is added at the end to ensure the next line isn't included in the value if it happens to be
                    // at the same indentation as the value.
                    newValue = newValue.replace(/\n/g, options.eol + "    ") + options.eol;
                    break;
                case "escape":
                    newValue = newValue.replace(/\n/g, "\\n");
                    break;
                case "\"\"\"":
                case "'''":
                default:
                    newValue = options.multilineStyle + newValue + options.multilineStyle;
                    break;
                }
            } else {
                var quote = (options.quote === "always" || (options.quote === "string" && typeof(s) === "string"));
                quote = quote || (options.quote === "spaces" && /^\s|\s$/.test(newValue));
                if (quote) {
                    newValue = options.quoteChar + newValue + options.quoteChar;
                }
            }
            output.push(key + options.keyValueDelimiter + newValue);
        }

        return output;
    };

    // The object of the section currently being dealt with.
    var currentSection = null;
    // Path of the current section.
    var currentPath = [];
    var currentPathString = "";
    // Use to separate path segments, while allowing '.' (dot) in the section/key names.
    var pathSep = "][";
    // A hash-map of the value paths that have been written, or where already there.
    var valuesWritten = {};

    /**
     * Get the values that have not been written to for the current section (that is, the new values).
     *
     * @param {Array<String>} sectionPath The path to the section object.
     * @param {Boolean} subSections true to return only sub-sections (objects), otherwise return values.
     * @return {Array<Object>} The key-value pairs that have yet to be written.
     */
    var getUnwrittenValues = function (sectionPath, subSections) {
        var items = [];
        var section = fluid.get(data, sectionPath);
        if (section) {
            var allKeys = Object.keys(section);
            var path = sectionPath.length ? sectionPath.join(pathSep) + pathSep : "";
            fluid.each(allKeys, function (key) {
                if (!valuesWritten[path + key]) {
                    var value = section[key];
                    if (fluid.isPlainObject(value) === !!subSections) {
                        items.push({
                            key: key,
                            value: value
                        });
                    }
                }
            });
        }
        return items;
    };

    var handlers = {
        /**
         * Called at the start of a new section.
         * Output unwritten values to the current section (before this one).
         *
         * @param {Array<String>} sectionPath The path to the new section object.
         * @return {String} The text to add before the new section, or fluid.NO_VALUE to remove the section.
         */
        sectionBegin: function (sectionPath) {
            var output = [];
            if (sectionPath.length > 0) {
                // Add the values to the previous section that haven't already been added.
                fluid.each(getUnwrittenValues(currentPath, false), function (tuple) {
                    output.push.apply(output, writeValue(tuple.key, tuple.value));
                });
            }
            currentPath = sectionPath.slice();
            currentSection = fluid.get(data, currentPath);

            currentPathString = currentPath.join(pathSep);
            valuesWritten[currentPathString] = true;

            return output.length && (output.join(options.eol) + options.eol);
        },

        /**
         * Called at the end of a section, after all of its sub-sections have been parsed.
         * Output the unwritten sub-sections of the section.
         *
         * @param {Array<String>} sectionPath The path to the section object.
         * @return {String} The text to add at the end of the section.
         */
        sectionEnd: function (sectionPath) {
            var output = [];

            if (sectionPath.length === 0 && currentPathString === "") {
                // Special case where at the end of a file with no sections, where sectionBegin wouldn't have been
                // called.
                output.push(handlers.sectionBegin(["dummy"]));
            }

            // Add the sub-sections to the section that haven't already been added.
            fluid.each(getUnwrittenValues(sectionPath, true), function (tuple) {
                output.push.apply(output, writeValue(tuple.key, tuple.value, sectionPath));
            });

            valuesWritten[currentPathString] = true;

            return output.length && (output.join(options.eol) + options.eol);
        },

        /**
         * Called when a value has been parsed. Return the updated value, if required.
         *
         * @param {String} sectionPath The path of the section.
         * @param {String} key The value name.
         * @param {String} value The value.
         * @return {String} The new value, fluid.NO_VALUE to remove the value, or undefined if it's unchanged.
         */
        gotValue: function (sectionPath, key, value) {

            if (currentSection && currentSection.hasOwnProperty(key)) {
                var newValue = stringify(currentSection[key]);

                var p = (currentPathString ? currentPathString + pathSep : "") + key;
                valuesWritten[p] = true;
                if (value !== newValue) {
                    return newValue;
                }
            } else if (!options.keepUndefined) {
                return fluid.NO_VALUE;
            }
        }
    };

    return gpii.iniFile.parse(input, handlers, options);
};

/**
 * Reads INI file content, returning the parsed data as an object.
 *
 * @param {String} content The ini file content.
 * @param {Object} options Options:
 * @param {Boolean} options.strings true to always return strings, otherwise try to return numbers and booleans for
 *  unquoted values, where appropriate.
 * @param {Boolean} options.firstDuplicate true to use the first occurrence of a value with a duplicate name, otherwise
 * the last is used. [default: false]
 *
 * @return {Object} The parsed ini file data.
 */
gpii.iniFile.read = function (content, options) {
    options = Object.assign({
        firstDuplicate: false
    }, options);

    var result = {};

    var handlers = {
        /**
         * Called at the start of a new section. Create an empty object for it.
         * @param {Array<String>} sectionPath The path to the new section object.
         */
        sectionBegin: function (sectionPath) {
            var existing = sectionPath.length && fluid.get(result, sectionPath);
            if (existing) {
                if (fluid.isPlainObject(existing)) {
                    fluid.log("iniFile - Warning: Merging sections with duplicate name: ",
                        sectionPath.join("."));
                } else {
                    fluid.log("iniFile - Warning: Overwriting key=value with section of the same name: ",
                        sectionPath.join("."));
                    fluid.set(result, sectionPath, {});
                }
            }
        },

        /**
         * Called when a value has been parsed.
         *
         * @param {String} sectionPath The path of the section.
         * @param {String} key The value name.
         * @param {String} value The value.
         * @param {Boolean} quoted true if the value was quoted.
         */
        gotValue: function (sectionPath, key, value, quoted) {
            // Ignore the value if it's already set, if only setting first duplicates.
            var set = !options.firstDuplicate || (fluid.get(result, sectionPath.concat(key), value) === undefined);
            if (!options.strings && !quoted) {
                // Try to convert it to a non-string value.
                if (/^([0-9]+|true|false|null)$/.test(value)) {
                    value = JSON.parse(value);
                }
            }
            if (set) {
                fluid.set(result, sectionPath.concat(key), value);
            }
        }
    };

    gpii.iniFile.parse(content, handlers, options);

    return result;
};

/**
 * Wrapper for read(), that reads from the given file.
 * @param {String} path The ini file.
 * @param {Object} options Options for read().
 * @return {Object} The result of read().
 */
gpii.iniFile.readFile = function (path, options) {
    var content = fs.readFileSync(path, "utf8");
    return gpii.iniFile.read(content, options);
};

/**
 * Wrapper for write(), that reads the initial data from the given file.
 *
 * @param {String} path The ini file.
 * @param {Object} data The new settings data.
 * @param {Object} options Options for write().
 * @return {Object} The result of write().
 */
gpii.iniFile.writeFromFile = function (path, data, options) {
    var content = fs.readFileSync(path, "utf8");
    return gpii.iniFile.write(content, data, options);
};
