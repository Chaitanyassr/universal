/**
 * GPII Journal.js
 *
 * Responsible for journalling the state of the system's settings in order to be able to recover from system crashes or corruption of the settings state
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 */

"use strict";

var fluid = require("infusion"),
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs"),
    writeFileAtomic = require("write-file-atomic"),
    glob = require("glob");

/** Manages reading and writing of journal files held within the "GPII settings directory",
 * managed in a suitable platform-specific area of the user's settings files.
 */

fluid.defaults("gpii.journal", {
    gradeNames: "fluid.component",
    maxOldJournals: 5,
    components: {
        settingsDir: {
            type: "gpii.settingsDir"
        }
    },
    events: {
        onUpdateSnapshot: null
    },
    listeners: {
        "onCreate.readJournals": "gpii.journal.readJournals({that})",
        "onCreate.trimJournals": {
            funcName: "gpii.journal.trimJournals",
            args: "{that}",
            priority: "after:readJournals"
        },
        "onCreate.findCrashed": {
            funcName: "gpii.journal.findCrashed",
            args: "{that}",
            priority: "after:trimJournals"
        }
    },
    invokers: {
        // args: {that}, {session}, {originalSettings}, closed
        writeJournal: "gpii.journal.writeJournal"
    }
});

/** A mixin grade supplied to gpii.journal accounting for its interaction with a lifecycleManager.
 * In the main architecture this is supplied with the journal's definition in gpii.flowManager.local,
 * which also incidentally assures that this component will definitely be constructed after the
 * lifecycleManager.
 */

fluid.defaults("gpii.journalLifecycleManager", {
    gradeNames: "fluid.component",
    events: {
        onSessionSnapshotUpdate: "{lifecycleManager}.events.onSessionSnapshotUpdate", // hack to evade FLUID-5925
        onSessionStop: "{lifecycleManager}.events.onSessionStop"
    },
    listeners: {
        onSessionSnapshotUpdate: {
            func: "{that}.writeJournal",
            args: ["{that}", "{arguments}.1", "{arguments}.1.model.originalSettings", false]
        },
        onSessionStop: {
            func: "{that}.writeJournal",
            args: ["{that}", "{arguments}.1", "{arguments}.1.model.originalSettings", true]
        }
    },
    invokers: {
        restoreJournal: {
            funcName: "gpii.journal.restoreJournal",
            args: ["{that}", "{lifecycleManager}", "{arguments}.0"] // journalId
        }
    }
});


gpii.journal.restoreJournal = function (journal, lifecycleManager, journalId) {
    var parsed = gpii.journal.parseId(journalId);
    if (parsed.isError) {
        fluid.fail(parsed.message);
    } else {
        fluid.log("Restoring journal with id " + journalId);
        var journal = gpii.journal.fetchJournal(journal.journalFiles, parsed);
        console.log("Restoring journal snapshot with contents " + JSON.stringify(journal, null, 2));
        return lifecycleManager.restoreSnapshot(journal.originalSettings);
    }
};

/** A mixin grade supplied to gpii.journal which converts it into a kettle app hosting an HTTP endpoint
  * currently just exposing the single function of restoring a particular journal
  */

fluid.defaults("gpii.journalApp", {
    gradeNames: "kettle.app",
    requestHandlers: {
        restore: {
            route: "/journal/restore/:journalId",
            method: "get",
            type: "gpii.journal.restoreJournal.handler",
        }
    }
});

fluid.defaults("gpii.journal.restoreJournal.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.journal.restoreJournal.handleRequest",
            args: [ "{gpii.journal}", "{that}"]
        }
    }
});

gpii.journal.restoreJournal.handleRequest = function (journal, request) {
    var journalId = request.req.params.journalId;
    var restorePromise = journal.restoreJournal(journalId);
    fluid.promise.follow(restorePromise, request.handlerPromise);
};

/** Formats a millisecond timestamp into an ISO-8601 date string which is safe to
  * appear in a filename
  * @param {Number} A millisecond timestamp, as dispensed from `Date.now()`
  * @return {String} An ISO-8601 date stamp without colon characters, e.g. 2016-07-05T220712.549Z
  */
gpii.journal.formatTimestamp = function (time) {
    var date = new Date(time);
    var stamp = date.toISOString();
    var safeStamp = stamp.replace(/:/g, ""); // This is still a valid ISO-8601 date string, but Date.parse() will no longer parse it
    return safeStamp;
};

gpii.journal.writeJournal = function (that, session, snapshot, closed) {
    var dir = that.settingsDir.getGpiiSettingsDir();
    var filename = "journal-" + gpii.journal.formatTimestamp(session.createTime) + ".json";
    var payload = {
        userToken: session.options.userToken,
        closed: closed,
        createTime: session.createTime,
        originalSettings: snapshot
    };
    var formatted = JSON.stringify(payload, null, 4);
    var fullPath = dir + "/" + filename;
    fluid.log("Writing journal file to path " + fullPath);
    writeFileAtomic.sync(fullPath, formatted);
};

// A comparator to sort journal entries in increasing order of age (newest first)
gpii.journal.dateComparator = function (journalA, journalB) {
    return journalB.createTime - journalA.createTime;
};

gpii.journal.readJournals = function (that) {
    var dir = that.settingsDir.getGpiiSettingsDir();
    var journalFileNames = glob.sync(dir + "/journal-*.json");
    console.log("Got journalFileNames ", journalFileNames);
    var journalFiles = fluid.transform(journalFileNames, function (journalFileName) {
        var readPromise = kettle.JSON.readFileSync(journalFileName, "reading journal file " + journalFileName);
        var togo;
        readPromise.then(function (read) {
            togo = read;
        }, function (err) {
            fluid.log(fluid.logLevel.WARN, "Error reading journal file " + journalFileName + ": " + err.message);
            togo = err;
        });
        togo.journalFileName = journalFileName;
        return togo;
    });
    journalFiles.sort(gpii.journal.dateComparator);
    that.journalFiles = journalFiles;
    console.log("Got journalFiles ", journalFiles);
};

gpii.journal.trimJournals = function (that) {
    if (that.journalFiles.length > that.options.maxOldJournals) {
        for (var i = that.options.maxOldJournals; i < that.journalFiles.length; ++i) {
            var journal = that.journalFiles[i];
            var fileName = journal.journalFileName;
            fluid.log("Removing old journal file " + fileName + " since maximum number of old journals is " + that.options.maxOldJournals);
            try {
                fs.unlinkSync(fileName);
            } catch (e) {
                fluid.log(fluid.logLevel.WARN, "Error deleting old journal " + fileName + ": " + e);
            }
        }
        that.journalFiles.length = that.options.maxOldJournals;
    }
};

gpii.journal.findCrashed = function (that) {
    var firstCrashed = fluid.find_if(that.journalFiles, function (journalFile) {
        return journalFile.closed === false;
    });
    if (firstCrashed) {
        that.crashedJournal = firstCrashed;
        fluid.log(fluid.logLevel.WARN, "Found crashed journal file on startup: " + JSON.stringify(firstCrashed, null, 2));
    } else {
        fluid.log("Found no crashed journals on startup");
    }
};
