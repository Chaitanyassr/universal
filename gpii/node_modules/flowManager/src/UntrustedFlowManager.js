/**
 * GPII Untrusted Local FlowManager
 *
 * Copyright 2015 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("accessRequester");
fluid.require("%universal/gpii/node_modules/gpii-oauth2/gpii-oauth2-utilities/src/OAuth2Utilities.js");

// The Untrusted or Hybrid (Local) FlowManager is a Local FlowManager which defers to the cloud for the matchMaking
// and Preferences fetch process. The architectural goal of the untrusted FlowManager is that the unfiltered
// user preferences never reach the local device. Therefore the userLogon stages of the "gpii.flowManager.matchMakingRequest"
// are all abridged, and instead we simply receive a final settings payload from a cloudBased flowManager which are
// then directly applied to the local device.

// Described at https://issues.gpii.net/browse/GPII-1224

// Overrides request handlers in "gpii.flowManager.local"

fluid.defaults("gpii.flowManager.untrusted", {
    components: {
        settingsDataSource: {
            type: "gpii.flowManager.untrusted.settingsDataSource"
            // untrustedSettingsUrl: distributed down from, e.g., gpii.flowManager.untrusted.config.development
            // accessTokenUrl: distributed down from, e.g., gpii.flowManager.untrusted.config.development
            // clientCredentialFilePath: distributed down from, e.g., gpii.flowManager.untrusted.config.development
        }
    },
    requestHandlers: {
        userLogin: {
            // NOTE that these gradesNames do not merge as with standard components
            gradeNames: "gpii.flowManager.untrusted.stateChangeHandler"
        },
        proximityTriggered: {
            gradeNames: "gpii.flowManager.untrusted.stateChangeHandler"
        }
    }
});


gpii.flowManager.untrusted.getSettings = function (settingsDataSource, userToken, deviceReporterData, onMatchDone, onError) {
    var settings = settingsDataSource.get(userToken, deviceReporterData);
    settings.then(onMatchDone.fire, onError.fire);
};


fluid.defaults("gpii.flowManager.untrusted.stateChangeHandler", {
    gradeNames: ["fluid.component", "gpii.flowManager.userLogonHandling.stateChangeHandler"],
    invokers: {
        getSettings: {
            funcName: "gpii.flowManager.untrusted.getSettings",
            args: [
                "{flowManager}.settingsDataSource",
                "{that}.userToken",
                "{arguments}.0", // device reporter data
                "{that}.events.onMatchDone",
                "{that}.events.onError"
            ]
        }
    },
    events: {
        onUserToken: null,
        onDeviceContext: null
    },
    listeners: {
        "onUserToken.setUserToken": {
            listener: "gpii.flowManager.setUserToken",
            args: ["{that}", "{arguments}.0"]
        },
        "onUserToken.getDeviceContext": {
            func: "{that}.getDeviceContext",
            priority: "after:setUserToken"
        },
        "onDeviceContext.getSettings": "{that}.getSettings"
    }
});

// gpii.flowManager.untrusted.settingsDataSource provides a get() API that returns a promise
// whose resolved value is user settings. The internal steps performed by this API:
// 1. check the access token requested last time. If it's still valid, use it to request then return user settings;
// 2. If the access token has not been requested or it has expired, request an access token via accessRequester subcomponent;
// 3. Save the received access token as member options;
// 4. Use the access token to request then return user settings.
fluid.defaults("gpii.flowManager.untrusted.settingsDataSource", {
    gradeNames: ["fluid.component"],

    // Options that are distributed down from, e.g., gpii.flowManager.untrusted.config.development
    untrustedSettingsUrl: null,
    accessTokenUrl: null,
    // TODO: Reading the client credential from the file system is a temporary solution. This option
    // should be removed once a proper access requester is in place (https://issues.gpii.net/browse/GPII-2436).
    clientCredentialFilePath: null,

    // The minimum number of seconds of the lfe time of an access token for it to continuing to be used.
    minAccessTokenLifeTimeInSecond: 10,
    distributeOptions: {
        untrustedSettingsUrl: {
            source: "{that}.options.untrustedSettingsUrl",
            target: "{that > untrustedSettingsDataSource}.options.url"
        },
        accessTokenUrl: {
            source: "{that}.options.accessTokenUrl",
            target: "{that > accessRequester}.options.url"
        },
        clientCredentialFilePath: {
            source: "{that}.options.clientCredentialFilePath",
            target: "{that clientCredentialDataSource}.options.path"
        }
    },

    members: {
        accessTokens: {
            // To keep track of the most recent access token and its expiresIn timestamp for each user token. The structure looks like:
            // "userToken1": {
            //     accessToken: "a-token-value",
            //     timestampExpires: "an-timestamp-the-token-expires"
            // }
            // ...
        }
    },
    components: {
        untrustedSettingsDataSource: {
            type: "kettle.dataSource.URL",
            options: {
                // url: distributed down from the parent component gpii.flowManager.untrusted.settingsDataSource
                termMap: {
                    "userToken": "%userToken",
                    "device": "%device"
                }
            }
        },
        accessRequester: {
            type: "gpii.accessRequester",
            options: {
                clientCredentialDataSourceGrade: "gpii.accessRequester.clientCredentialDataSource.file"
            }
        }
    },
    invokers: {
        get: {
            funcName: "gpii.flowManager.untrusted.settingsDataSource.get",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
            // userToken, device
        },
        save: {
            funcName: "gpii.flowManager.untrusted.settingsDataSource.save",
            args: ["{that}.accessTokens", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
            // userToken, accessToken, timestampExpires
        }
    }
});

/**
 * Retrieve user settings from the cloud using the access token requested for they keyed in user token.
 * @param that {Component} An instance of gpii.flowManager.untrusted.settingsDataSource
 * @param userToken {String} A user token
 * @param device {Object} The device information provided by the device reporter
 * @return {Promise} A promise whose resolved value is the user settings
 */
gpii.flowManager.untrusted.settingsDataSource.get = function (that, userToken, device) {
    var accessTokenPromise = gpii.flowManager.untrusted.settingsDataSource.findValidAccessToken(that, userToken);
    var promiseTogo = fluid.promise();

    accessTokenPromise.then(function (accessToken) {
        var settingsPromise = that.untrustedSettingsDataSource.get({
            userToken: userToken,
            device: JSON.stringify(device)
        }, {
            headers: {
                "Authorization": "Bearer " + accessToken
            }
        });
        fluid.promise.follow(settingsPromise, promiseTogo);
    }, function (err) {
        promiseTogo.reject(err);
    });

    return promiseTogo;
};

/**
 * Find a valid access token. It first checks the saved access token for the keyed in user token,
 * If it has expired, request and return a new one from the cloud, otherwise, return the saved access token.
 * @param that {Component} An instance of gpii.flowManager.untrusted.settingsDataSource
 * @param userToken {String} A user token
 * @return {Promise} A promise whose resolved value is a valid access token
 */
gpii.flowManager.untrusted.settingsDataSource.findValidAccessToken = function (that, userToken) {
    var allAccessTokens = that.accessTokens;

    var accessToken = fluid.get(allAccessTokens, [userToken, "accessToken"]);
    var expiresIn = gpii.oauth2.getExpiresIn(new Date(), fluid.get(allAccessTokens, [userToken, "timestampExpires"]));

    // If the locally saved access token exists and is still valid, return it.
    // Otherwise, request an new access token from the cloud and return.
    // The new access token is saved locally for the continuing use.
    if (!accessToken || !expiresIn || expiresIn < that.options.minAccessTokenLifeTimeInSecond) {
        var accessTokenPromise = that.accessRequester.getAccessToken(userToken);
        var mapper = function (accessTokenObj) {
            var accessTokenFromCloud = accessTokenObj.access_token;
            var timestampExpiresFromCloud = gpii.oauth2.getTimestampExpires(new Date(), accessTokenObj.expiresIn);
            that.save(userToken, accessTokenFromCloud, timestampExpiresFromCloud);
            return accessTokenFromCloud;
        };
        return fluid.promise.map(accessTokenPromise, mapper);
    } else {
        return fluid.promise().resolve(accessToken);
    }
};

/**
 * Save the access token and its timestampExpires in the index of the user token for the next use.
 * @param that {Component} An instance of gpii.flowManager.untrusted.settingsDataSource
 * @param userToken {String} The user token that the access token associates with
 * @param accessToken {String} The access token to be saved
 * @param timestampExpires {String} A timestampExpires to be saved
 * @return {Promise} A promise whose resolved value is a valid access token
 */
gpii.flowManager.untrusted.settingsDataSource.save = function (allAccessTokens, userToken, accessToken, timestampExpires) {
    fluid.set(allAccessTokens, [userToken, "accessToken"], accessToken);
    fluid.set(allAccessTokens, [userToken, "timestampExpires"], timestampExpires);
};
