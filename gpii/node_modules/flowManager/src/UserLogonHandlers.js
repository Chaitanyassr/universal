/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015, 2017 Raising the Floor - International
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.proximityTrigger.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.proximityTrigger.handleRequest",
            args: ["{that}", "{flowManager}.lifecycleManager", "{request}.req.params.gpiiKey"]
        },
        isBounce: {
            funcName: "gpii.flowManager.proximityTrigger.handler.isBounce",
            args: ["{flowManager}.lifecycleManager", "{that}.options.debounceTimeMs", "{arguments}.0"]
                                                                                      // gpiiKey
        }
    }
});

/**
 * Function to check whether a proximity trigger should bounce
 *
 * @param {Component} lifecycleManager - The lifecycleManager module.
 * @param {Integer} debounceTimeMs - The time in milliseconds for which to debounce after last proximityTrigger was fired.
 * @param {String} gpiiKey - The GPII key of the user for whom the proximityTrigger was fired.
 * @return {Boolean} Returns true if the proximityTrigger should be ignored (i.e. is considered a bounce). This is done according
 *              to the following rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 *              OR if the last login/logout process for <myGpiiKey> finished less than {debounceTimeMs} milliseconds ago
 */
gpii.flowManager.proximityTrigger.handler.isBounce = function (lifecycleManager, debounceTimeMs, gpiiKey) {
    // if login/logout is in progress for <gpiiKey> we consider it a bounce
    var now = Date.now();
    var model = lifecycleManager.model;
    if (gpiiKey === model.logonChange.gpiiKey) {
        return model.logonChange.inProgress || now - lifecycleManager.model.logonChange.timeStamp < debounceTimeMs;
    } else {
        return false;
    }
};

/*
 * /user/:gpiiKey/proximityTriggered handler
 * RFID with <myGpiiKey>:
 * * Debounce rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 * *                OR if the last login/logout process for <myGpiiKey> finished less than 1.5 seconds ago
 * * If no user is logged in and debounce doesn't apply, log in <myGpiiKey>
 * * If <myGpiiKey> is logged in and debounce doesn't apply, log out <myGpiiKey>
 * * If another user is already logged in or in the process of logging in or out, log that user out and log in <myGpiiKey>
 */
gpii.flowManager.proximityTrigger.handleRequest = function (that, lifecycleManager, gpiiKey) {
    fluid.log("proximity triggered by GPII key: ", gpiiKey);
    // find currently logged in user:
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys();

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (that.isBounce(gpiiKey, that)) {
        fluid.log("Proximity trigger ignored due to bounce rules");
        that.errorResponse("Proximity trigger ignored due to bounce rules. Please wait current logon change is complete", 429);
        return;
    }

    if (activeGpiiKeys.length === 0) { // if no user is logged in
        that.loginUser(gpiiKey);
        return;
    }

    // if user is already logged in, log them out. If it's a different user who is logged in
    // log that user out before logging in with the new user
    if (activeGpiiKeys.length === 1) {
        var previousUser = activeGpiiKeys[0];
        if (previousUser !== gpiiKey) {
            var promise = that.logoutUserWithoutResponse(previousUser);
            promise.then(function () {
                that.loginUser(gpiiKey);
            }, function () {
                that.errorResponse("Unable to log previous user out so canceling login.");
            });
        } else {
            that.logoutUser(previousUser);
        }
    }
};

// Incomplete grade - local FlowManager adds "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler",
// whereas untrusted adds "gpii.flowManager.untrusted.stateChangeHandler"

fluid.defaults("gpii.flowManager.userLogin.handler", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogin.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{lifecycleManager}", "{that}"]
        }
    }
});

/*
 * Handler for URL: /user/<myGpiiKey>/login:
 * * If no user is logged in, <myGpiiKey> will be logged in
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */
gpii.flowManager.userLogin.handleRequest = function (gpiiKey, lifecycleManager, that) {
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys(); // find currently logged in user:

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (activeGpiiKeys.length === 1) { // if another user is already logged in:
        that.errorResponse("Got log in request from user " + gpiiKey + ", but the user " +
            activeGpiiKeys[0] + " is already logged in. So ignoring login request.", 409);
        return;
    }
    that.loginUser(gpiiKey);
};

fluid.defaults("gpii.flowManager.userLogout.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.userLogonHandling.stateChangeHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogout.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{flowManager}.lifecycleManager", "{that}"]
        }
    }
});

/**
 * Handler for the URL /user/<myGpiiKey>/logout:
 * * If no user is logged in, nothing happens
 * * if user myGpiiKey is logged in, he will be used out
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */

gpii.flowManager.userLogout.handleRequest = function (gpiiKey, lifecycleManager, that) {
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys(); // find currently logged in user:

    if (gpiiKey === "reset") {
        gpii.flowManager.userLogonHandling.handleResetGpiiKey(activeGpiiKeys[0], that);
        return;
    }

    if (activeGpiiKeys.length === 0) { // if no user is logged in
        that.errorResponse("No user logged in, so ignoring logout action.", 409);
        return;
    }

    if (activeGpiiKeys[0] === gpiiKey) {
        that.logoutUser(activeGpiiKeys[0]);
    } else {
        that.errorResponse("Got logout request from user " + gpiiKey + ", but the user " +
            activeGpiiKeys[0] + " is logged in. So ignoring the request.", 409);
    }
};
