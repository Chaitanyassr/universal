/*
 * GPII User Logon State Change
 *
 * Copyright 2012 OCAD University
 * Copyright 2015, 2017 Raising the Floor - International
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.flowManager.baseHandler", {
    gradeNames: ["fluid.component"],
    invokers: {
        errorResponse: {
            funcName: "gpii.flowManager.baseHandler.errorResponse",
            args: ["{request}", "{lifecycleManager}.userErrors", "{arguments}.0", "{arguments}.1"]
                                                                 // message, statusCode
        }
    }
});

gpii.flowManager.baseHandler.errorResponse = function (that, userErrors, message, statusCode) {
    userErrors.events.userError.fire({
        isError: true,
        messageKey: "KeyInFail",
        originalError: message
    });

    that.events.onError.fire({
        statusCode: statusCode || 500,
        message: message || "Unknown error occurred on logon change action"
    });
};

// Request handler for /user/:gpiiKey/proximityTriggered
fluid.defaults("gpii.flowManager.proximityTrigger.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.baseHandler"],
    debounceTimeMs: 1500,
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.proximityTrigger.handleRequest",
            args: ["{that}", "{flowManager}.lifecycleManager", "{request}.req.params.gpiiKey", "{request}"]
        },
        isBounce: {
            funcName: "gpii.flowManager.proximityTrigger.handler.isBounce",
            args: ["{flowManager}.lifecycleManager", "{that}.options.debounceTimeMs", "{arguments}.0"]
                                                                                      // gpiiKey
        }
    }
});

/**
 * Function to check whether a proximity trigger should bounce
 *
 * @param {Component} lifecycleManager - The lifecycleManager module.
 * @param {Integer} debounceTimeMs - The time in milliseconds for which to debounce after last proximityTrigger was fired.
 * @param {String} gpiiKey - The GPII key of the user for whom the proximityTrigger was fired.
 * @return {Boolean} Returns true if the proximityTrigger should be ignored (i.e. is considered a bounce). This is done according
 *              to the following rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 *              OR if the last login/logout process for <myGpiiKey> finished less than {debounceTimeMs} milliseconds ago
 */
gpii.flowManager.proximityTrigger.handler.isBounce = function (lifecycleManager, debounceTimeMs, gpiiKey) {
    // if login/logout is in progress for <gpiiKey> we consider it a bounce
    var now = Date.now();
    var currentLogonChange = lifecycleManager.model.logonChange;
    var lastNonNoUserLogon = lifecycleManager.model.lastNonNoUserLogon;

    if (currentLogonChange.gpiiKey === "noUser" && currentLogonChange.type === "login" && !currentLogonChange.inProgress) {
        return lastNonNoUserLogon.gpiiKey === gpiiKey && now - lifecycleManager.model.lastNonNoUserLogon.timeStamp < debounceTimeMs;
    } else if (gpiiKey === currentLogonChange.gpiiKey) {
        return currentLogonChange.inProgress || now - currentLogonChange.timeStamp < debounceTimeMs;
    } else {
        return false;
    }
};

/*
 * /user/:gpiiKey/proximityTriggered handler
 * RFID with <myGpiiKey>:
 * * Debounce rule: any RFID actions is ignored for <myGpiiKey> if a login/logout for <myGpiiKey> is in progress
 * *                OR if the last login/logout process for <myGpiiKey> finished less than 1.5 seconds ago
 * * If no user is logged in and debounce doesn't apply, log in <myGpiiKey>
 * * If <myGpiiKey> is logged in and debounce doesn't apply, log out <myGpiiKey>
 * * If another user is already logged in or in the process of logging in or out, log that user out and log in <myGpiiKey>
 */
gpii.flowManager.proximityTrigger.handleRequest = function (that, lifecycleManager, gpiiKey, request) {
    fluid.log("proximity triggered by GPII key: ", gpiiKey);
    // find currently logged in user:
    var activeGpiiKeys = lifecycleManager.getActiveSessionGpiiKeys();

    if (that.isBounce(gpiiKey, that)) {
        fluid.log("Proximity trigger ignored due to bounce rules");
        that.errorResponse("Proximity trigger ignored due to bounce rules. Please wait current logon change is complete", 429);
        return;
    }

    // if no user is logged in, request a login
    // if the login user is "reset", trigger the reset process via login with "reset" key
    if (activeGpiiKeys.length === 0 || gpiiKey === "reset") {
        var loginPromise = lifecycleManager.addToUserLogonRequestQueue({
            gpiiKey: gpiiKey,
            logonState: "login"
        });
        loginPromise.then(request.events.onSuccess.fire, request.events.onError.fire);
        return;
    }

    // if user is already logged in, log them out. If it's a different user who is logged in
    // log that user out before logging in with the new user
    if (activeGpiiKeys.length === 1) {
        var previousUser = activeGpiiKeys[0];
        if (previousUser !== gpiiKey) {
            var logoutPreviousUserPromise = lifecycleManager.addToUserLogonRequestQueue({
                gpiiKey: previousUser,
                logonState: "logout"
            });
            logoutPreviousUserPromise.then(function () {
                var loginPromise = lifecycleManager.addToUserLogonRequestQueue({
                    gpiiKey: gpiiKey,
                    logonState: "login"
                });
                loginPromise.then(request.events.onSuccess.fire, request.events.onError.fire);
            }, function () {
                that.errorResponse("Unable to log previous user(" + previousUser + ") out so canceling login.");
            });
        } else {
            var logoutPromise = lifecycleManager.addToUserLogonRequestQueue({
                gpiiKey: previousUser,
                logonState: "logout"
            });
            logoutPromise.then(request.events.onSuccess.fire, request.events.onError.fire);
        }
    }
};

// Request handler for /user/<myGpiiKey>/login
fluid.defaults("gpii.flowManager.userLogin.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.baseHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogin.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{request}", "{lifecycleManager}"]
        }
    }
});

/*
 * Handler for URL: /user/<myGpiiKey>/login:
 * * If no user is logged in, <myGpiiKey> will be logged in
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */
gpii.flowManager.userLogin.handleRequest = function (gpiiKey, request, lifecycleManager) {
    var loginPromise = lifecycleManager.addToUserLogonRequestQueue({
        gpiiKey: gpiiKey,
        logonState: "login"
    });
    loginPromise.then(request.events.onSuccess.fire, request.events.onError.fire);
};

// Request handler for /user/<myGpiiKey>/logout
fluid.defaults("gpii.flowManager.userLogout.handler", {
    gradeNames: ["kettle.request.http", "gpii.flowManager.baseHandler"],
    invokers: {
        handleRequest: {
            funcName: "gpii.flowManager.userLogout.handleRequest",
            args: ["{request}.req.params.gpiiKey", "{request}", "{flowManager}.lifecycleManager"]
        }
    }
});

/**
 * Handler for the URL /user/<myGpiiKey>/logout:
 * * If no user is logged in, nothing happens
 * * if user myGpiiKey is logged in, he will be used out
 * * If another user is logged in, nothing will happen
 * * If GPII key is "reset", log out any already logged in user.
 */

gpii.flowManager.userLogout.handleRequest = function (gpiiKey, request, lifecycleManager) {
    var logoutPromise = lifecycleManager.addToUserLogonRequestQueue({
        gpiiKey: gpiiKey,
        logonState: "logout"
    });
    logoutPromise.then(request.events.onSuccess.fire, request.events.onError.fire);
};
