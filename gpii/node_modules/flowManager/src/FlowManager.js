/*
 * GPII Flow Manager
 *
 * Copyright 2012 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

require("kettle");

require("./UserLogonStateChange.js");
require("./UserSave.js");
require("./GetGpiiKey.js");
require("./BrowserChannel.js");
require("./PSPChannel.js");
require("./CloudBasedFlowManager.js"); // TODO: move this include to be operated by a config
require("./UntrustedSettingsGetHandler.js");
require("./UntrustedSettingsPutHandler.js");
require("./UntrustedSettingsDataSource.js");
require("./UntrustedFlowManager.js");
require("./Snapshot.js");

require("preferencesServer");
require("lifecycleManager");
require("transformer");
require("journal");
require("singleInstance");
require("eventLog");

fluid.defaults("gpii.flowManager", {
    gradeNames: ["kettle.app"],
    matchMakers: {},
    components: {
        solutionsRegistryDataSource: {
            type: "kettle.dataSource",
            options: {
                termMap: {
                    "os": "%os",
                    "version": "%version"
                },
                components: {
                    encoding: {
                        type: "kettle.dataSource.encoding.JSON5"
                    }
                }
            }
        },
        preferencesDataSource: {
            type: "kettle.dataSource",
            options: {
                termMap: {
                    gpiiKey: "%gpiiKey"
                },
                writable: true
            }
        },
        matchMakerFramework: {
            type: "gpii.matchMakerFramework",
            options: {
                matchMakers: "{gpii.flowManager}.options.matchMakers"
            }
        },
        browserChannel: {
            type: "gpii.flowManager.browserChannel"
        },
        ontologyHandler: {
            type: "gpii.ontologyHandler"
        }
    }
});


// Mixin grades for the FlowManager

fluid.defaults("gpii.flowManager.local", {
    components: {
        lifecycleManager: {
            type: "gpii.lifecycleManager"
        },
        deviceReporterDataSource: {
            type: "kettle.dataSource"
        },
        journal: {
            type: "gpii.journal",
            options: {
                gradeNames: ["gpii.journalLifecycleManager", "gpii.journalApp"]
            }
        },
        eventLog: {
            type: "gpii.eventLog",
            options: {
                gradeNames: ["gpii.eventLog"]
            }
        },
        userListeners: {
            type: "gpii.userListeners",
            options: {
                gradeNames: ["gpii.userListeners"]
            }
        },
        capture: {
            type: "gpii.flowManager.capture"
        }
    },
    requestHandlers: {
        userLogin: {
            route: "/user/:gpiiKey/login",
            method: "get",
            type: "gpii.flowManager.userLogin.handler",
            gradeNames: "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler"
        },
        userLogout: {
            route: "/user/:gpiiKey/logout",
            method: "get",
            type: "gpii.flowManager.userLogout.handler"
        },
        proximityTriggered: {
            route: "/user/:gpiiKey/proximityTriggered",
            method: "get",
            type: "gpii.flowManager.proximityTrigger.handler",
            gradeNames: "gpii.flowManager.userLogonHandling.matchMakingStateChangeHandler"
        },
        getGpiiKey: {
            route: "/gpiiKey",
            method: "get",
            type: "gpii.flowManager.getGpiiKey.handler"
        },
        capture: {
            route: "/capture",
            method: "get",
            type: "gpii.flowManager.capture.handler"
        }
    },
    listeners: {
        "onCreate": "gpii.singleInstance.registerInstance",
        "afterDestroy": "gpii.singleInstance.deregisterInstance"
    }
});

fluid.defaults("gpii.flowManager.capture", {
    gradeNames: ["fluid.component"],
    events: {
        onPrepareCapture: null,
        onPrepareSolutions: null,
        onSolutions: null,
        onReadyToCapture: {
            events: {
                prepareCapture: "onPrepareCapture",
                prepareSolutions: "onPrepareSolutions",
                solutions: "onSolutions"
            },
            args: [
                "{arguments}.solutions.0",
                "{arguments}.prepareCapture.0"
            ]
        },
        onError: null
    },
    listeners: {
        "onPrepareCapture.deviceContext": {
            funcName: "gpii.flowManager.getDeviceContext",
            args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onPrepareSolutions"]
        },
        onPrepareSolutions: {
            func: "{that}.getSolutions",
            args: ["{arguments}.0"]
        },
        onReadyToCapture: {
            func: "{that}.captureSystemSettings",
            args: ["{arguments}.0", "{arguments}.1"]
        },
        onError: {
            funcName: "console.log",
            args: ["{arguments}.0"]
        }
    },
    invokers: {
        getSolutions: {
            funcName: "gpii.flowManager.getSolutions",
            args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutions", "{that}.events.onError"] //"{request}.events.onError"]
        },
        captureSystemSettings: {
            funcName: "gpii.flowManager.captureSystemSettings",
            args: ["{lifecycleManager}.variableResolver", "{arguments}.0", "{arguments}.1"]
        }
    }
});

/**
 * Runs through all the solutions currently available on the system, pulls the current
 * setting for each supportedSetting and returns them in an object. Primary use case
 * is for backing Capture tools that would allow a user to set up their GPII profile
 * starting with the current settings for their applications on the local machine.
 *
 * @param {lifecycleManager.variableResolver} resolver - Resolver for looking up handler specifications
 * @param {Object} solutions - Solutions registry entries for solutions available on the current machine.
 * @param {event} event - Event to call with the payload as an argument after processing.
 * @return Returns nothing. Results are fired as an argument to the `event` argument.
 */
gpii.flowManager.captureSystemSettings = function (resolver, solutions, event) {
    var payload = {};
    fluid.each(solutions, function (solution, solutionID) {
        fluid.each(solution.settingsHandlers, function (handlerSpec) {
            //if applicationSettings is unspecified, dont attempt to get settings
            if (!handlerSpec.supportedSettings) {
                return;
            }

            handlerSpec.settings = handlerSpec.supportedSettings;
            handlerSpec = resolver.resolve(handlerSpec, {});

            var settingsHandlerPayload =
                gpii.lifecycleManager.specToSettingsHandler(solutionID, handlerSpec);

            var type = handlerSpec.type + "get";

            //send the payload to the settingsHandler
            var handlerResponse;
            try {
                // At the time of writing that only setting handler on windows that seemed to
                // be missing their get function was `gpii.settingsHandlers.noSettings`
                if (!fluid.getGlobalValue(type)) {
                    fluid.warn("Could not find get handler during snapshotting for: ", type);
                    return;
                }
                handlerResponse = fluid.invokeGlobalFunction(type, [settingsHandlerPayload]);
            } catch (e) {
                // TODO Some of the windows setting handlers seem to be throwing errors
                fluid.error("Problem capturing setting: " + type);
                return;
            }
            fluid.each(handlerResponse.value, function (settingsEntries, solutionId) {
                payload["http://registry.gpii.org/applications/" + solutionId] = [{
                    "value": settingsEntries[0].settings
                }];
            });
        });
    });
    fluid.log("Snapshotted the settings: " + JSON.stringify(payload, null, 4));
    event.fire(payload);
};

fluid.defaults("gpii.flowManager.save", {
    requestHandlers: {
        userSavePost: {
            route: "/user/preferences",
            method: "post",
            type: "gpii.flowManager.userSave.handler"
        },
        userSavePut: {
            route: "/user/preferences/:gpiiKey",
            method: "put",
            type: "gpii.flowManager.userSave.handler"
        }
    },
    distributeOptions: {
        record: {
            writable: true,
            writeMethod: "POST"
        },
        target: "{that > preferencesDataSource}.options"
    }
});


fluid.defaults("gpii.flowManager.ws", {
    requestHandlers: {
        browserChannel: {
            route: "/browserChannel",
            type: "gpii.flowManager.browserChannel.handler"
        },
        pspChannel: {
            route: "/pspChannel",
            type: "gpii.pspChannel.handler"
        }
    },
    components: {
        webSocketsSettingsHandlerComponent: {
            type: "gpii.settingsHandlers.webSockets.component"
        },
        pspChannel: {
            type: "gpii.pspChannel"
        }
    },
    listeners: {
        onCreate: [{
            funcName: "gpii.flowManager.mountWebSocketsSettingsHandler",
            args: ["{webSocketsSettingsHandlerComponent}"]
        }]
    }
});


gpii.flowManager.mountWebSocketsSettingsHandler = function (webSocketsSettingsHandlerComponent) {
    gpii.settingsHandlers.webSockets.instance = webSocketsSettingsHandlerComponent;
};
