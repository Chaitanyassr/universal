"use strict";


var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.flowManager");

// A mixin grade applied to the lifecycleManager's session by the pcpChannel
fluid.defaults("gpii.pcpChannel.sessionBinder", {
    modelRelay: {
        pcpChannel: {
            source: { // Not "" because of FLUID-6192
                segs: []
            },
            target: "{flowManager}.pcpChannel.model",
            singleTransform: {
                type: "gpii.pcpChannel.sessionToPCP",
                ontologyMetadata: "{ontologyHandler}.ontologyMetadata"
            },
            // compensate for FLUID-6194
            backward: "never",
            forward: {
                // avoid notifying the client for the init of LifecycleManagerSession, simplifies test and clients
                excludeSource: "init"
            }
        }
    },
    modelListeners: {
        pcpChannel: {
            path: "{flowManager}.pcpChannel.model.preferences",
            funcName: "gpii.pcpChannel.updatePreferences",
            includeSource: "PCP",
            args: ["{flowManager}.lifecycleManager", "{change}.value"]
        }
    }
});

fluid.defaults("gpii.pcpChannel", {
    gradeNames: ["fluid.modelComponent"],
    distributeOptions: {
        // Not {lifecycleManager session} because of FLUID-6193
        target: "{flowManager lifecycleManager session}.options.gradeNames",
        record: "gpii.pcpChannel.sessionBinder"
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "pcpChannel",
            funcName: "gpii.pcpChannel.sessionStop",
            args: "{pcpChannel}"
        }
    }
});

fluid.logObjectRenderChars = 10240;

gpii.pcpChannel.updatePreferences = function (lifecycleManager, newPrefs) {
    // TODO: to be implemented - must run a "mini-matchmaker cycle" via the lifecycleManager or otherwise
    fluid.log("Received update from PCP UI of ", newPrefs);
};

gpii.pcpChannel.filterSolution = function (solution) {
    return {
        name: solution.name,
        settingsHandlers: fluid.transform(solution.settingsHandlers, function (oneHandler) {
            return fluid.filterKeys(oneHandler, ["supportedSettings"
            // We expect that the matchMakerOutput will be accurate enough that the PCP will not require to consult these
            //, "capabilities", "capabilitiesTransformations"
            ]);
        })
    };
};

gpii.pcpChannel.filterSchema = function (schema) {
    return schema && fluid.censorKeys(schema, "default");
};

gpii.pcpChannel.emitSettingControl = function (settingControls, schema, prefVal, keySegs, solutionName) {
    var fullKey = fluid.pathUtil.composeSegments.apply(null, keySegs);
    if (schema) {
        settingControls[fullKey] = {
            value: prefVal,
            schema: gpii.pcpChannel.filterSchema(schema),
            solutionName: solutionName
        };
    }
};

gpii.pcpChannel.sessionToPCP = function (model, transformSpec) {
    var schemas = transformSpec.ontologyMetadata.flat.schemas;
    var outModel = fluid.filterKeys(model, ["userToken", "activeContextName"]);
    // fluid.log("processing model ", model);
    var settingControls = {};
    var activePreferences = fluid.get(model, ["preferences", "contexts", model.activeContextName, "preferences"]); 
    fluid.each(activePreferences, function (prefsVal, prefsKey) {
        if (prefsKey.startsWith("http://registry.gpii.net/applications")) {
            var solKey = prefsKey.substring("http://registry.gpii.net/applications/".length);
            var solution = model.solutionsRegistryEntries[solKey];
            if (solution) {
                fluid.each(prefsVal, function (innerPrefsVal, innerPrefsKey) {
                    gpii.pcpChannel.emitSettingControl(settingControls, schemas[innerPrefsKey], innerPrefsVal, [prefsKey, innerPrefsKey], solution.name);
                });
            }
        } else {
            gpii.pcpChannel.emitSettingControl(settingControls, schemas[prefsKey], prefsVal, [prefsKey]);
        }
    });
    outModel.settingControls = settingControls;
    fluid.set(outModel, "preferences.contexts", fluid.transform(fluid.get(model, "preferences.contexts"), function (contextVal) {
        return fluid.filterKeys(contextVal, ["name"]);
    }));
    /* Old-style API
    var activeCommonTerms = {}, activeSolutions = {};
    fluid.each(fluid.get(model, ["matchMakerOutput", "inferredConfiguration"]), function (contextVal) {
        var applications = contextVal.applications;
        fluid.each(applications, function (appVal, application) {
            activeSolutions[application] = true;
            fluid.each(appVal.settings, function (settingVal, settingName) {
                if (!settingName.startsWith("http://registry.gpii.net/applications")) {
                    activeCommonTerms[settingName] = true;
                }
            });
        });
    });
    fluid.each(activeCommonTerms, function (troo, preference) {
        var outSchema = gpii.pcpChannel.filterSchema(ontologyMetadata.flat.schemas[preference]);
        if (outSchema) {
            fluid.set(outModel, ["commonTermsMetadata", preference, "schema"], outSchema);
        } else {
            // TODO: Remove term both from preferences and matchMakerOutput
        }
    });
    */
    /* This will not be operated until we have genuine application-specific terms in snapsets
    fluid.each(activeSolutions, function (troo, solution) {
        fluid.set(outModel, ["solutionsRegistryEntries", solution],
            gpii.pcpChannel.filterSolution(model.solutionsRegistryEntries[solution]));
    });
    */
    return outModel;
};


gpii.pcpChannel.modelChangeListener = function (handler, value, oldValue, path, transaction) {
    console.log("## on modelChangeListener, sources are ", fluid.keys(transaction.source));
    if (!transaction.sources.PCP) {
        console.log("## source is not PCP");
        var changes = fluid.modelPairToChanges(value, oldValue);
        if (fluid.find(changes, function (change) {
            return change.type === "DELETE";
        })) {
            changes.forEach(function (change) {
                handler.sendMessage(change);
            });
        } else {
            handler.sendMessage({path: [], type: "ADD", value: value});
        }
    }
};

gpii.pcpChannel.sessionStop = function (pcpChannel) {
    pcpChannel.applier.change("", null, "DELETE");
};

fluid.defaults("gpii.pcpChannel.handler", {
    gradeNames: ["kettle.request.ws"],
    invokers: {
        modelChangeListener: {
            funcName: "gpii.pcpChannel.modelChangeListener",
            // value, oldValue, pathSegs, transaction: http://docs.fluidproject.org/infusion/development/ChangeApplierAPI.html#programmatic-style-for-listening-to-changes
            args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.4"]
        }
    },
    listeners: {
        onBindWs: {
            funcName: "gpii.pcpChannel.bindWs",
            args: ["{that}", "{pcpChannel}"]
        },
        onReceiveMessage: {
            funcName: "gpii.pcpChannel.receiveMessage",
            args: ["{that}", "{arguments}.1"]
        },
        "onDestroy.unbindModel": {
            func: "{pcpChannel}.applier.modelChanged.removeListener",
            args: ["{that}.id"]
        }
    }
});

gpii.pcpChannel.bindWs = function (handler, pcpChannel) {
    pcpChannel.applier.modelChanged.addListener("", handler.modelChangeListener, handler.id);
    // Note that this is inconsistent with the Nexus' protocol, but is more correct - for example if the model consists
    // purely of a primitive or is undefined, the initial Nexus message will break
    handler.sendMessage({path: [], type: "ADD", value: pcpChannel.model});
};

gpii.pcpChannel.receiveMessage = function (that, message, pcpChannel) {
    fluid.log("pcpChannel received a message: ", message);
    pcpChannel.applier.change(message.path, message.value, "ADD", "PCP");
};
