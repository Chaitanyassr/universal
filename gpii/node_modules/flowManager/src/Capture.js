/**
 * GPII snapshot Handler
 *
 * Copyright 2014 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 */
"use strict";

var fs = require("fs"),
    fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.flowManager.capture", {
    gradeNames: ["fluid.component"],
    events: {
        onSolutionsForCurrentDevice: null,
        onCaptureSettingsForCurrentDevice: null
    },
    listeners: {
        onSolutionsForCurrentDevice: [
            {
                funcName: "gpii.lifecycleManager.getDeviceContextPromise",
                args: ["{flowManager}.deviceReporter"]
            },
            {
                funcName: "gpii.flowManager.getSolutionsPromise",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0"]
            },
            {
                funcName: "fluid.toPromise",
                args: ["{arguments}.0.solutionsRegistryEntries"]
            }
        ],
        onCaptureSettingsForCurrentDevice: [
            {
                func: "{that}.getInstalledSolutions"
            },
            {
                func: "{that}.captureSystemSettings",
                args: ["{arguments}.0", "{arguments}.1"]
            }
        ]
    },
    invokers: {
        getInstalledSolutions: {
            funcName: "gpii.flowManager.getInstalledSolutions",
            args: ["{that}"]
        },
        getSystemSettingsCapture: {
            funcName: "gpii.flowManager.getSystemSettingsCapture",
            args: ["{that}.events.onCaptureSettingsForCurrentDevice", "{arguments}.0"] // Options
        },
        captureSystemSettings: {
            funcName: "gpii.flowManager.captureSystemSettings",
            args: ["{lifecycleManager}.invokeSettingsHandlerGet", "{lifecycleManager}.variableResolver",
                "{lifecycleManager}.userSession.localResolver", "{arguments}.0", "{arguments}.1"]
        }
    }
});


gpii.flowManager.getInstalledSolutions = function (that) {
    return fluid.promise.fireTransformEvent(that.events.onSolutionsForCurrentDevice);
};

/**
 * This main API entry point for capturing settings from a system or computer. This captures
 * the actual settings on the device, so it assumed to be running in a local untrusted flow
 * manager.
 *
 * @param {Event} onCaptureSettingsForCurrentDevice - The transforming promise chain
 * @param {Object} options - Options for this chain.
 * @param {Array} options.solutionsList - An array of solution IDs to filter by when
 * retreiving settings. If this option is not included, all available settings will be
 * returned. ex: `["com.microsoft.windows.mouseSettings", "com.freedomscientific.jaws"]`.
 * @return {Promise} A promise resolved with the payload of captured system settings.
 */
gpii.flowManager.getSystemSettingsCapture = function (onCaptureSettingsForCurrentDevice, options) {
    return fluid.promise.fireTransformEvent(onCaptureSettingsForCurrentDevice,
        {}, options);
};

/*
 * Runs through all the solutions currently available on the system, pulls the current
 * setting for each supportedSetting and returns them in an object. Primary use case
 * is for backing Capture tools that would allow a user to set up their GPII profile
 * starting with the current settings for their applications on the local machine.
 *
 * @param {lifecycleManager.invokeSettingsHandlerGet} invokeSettingsHandlerGet - Invoker from the `lifecycleManager`
 * necessary for extracting settings from a solution and it's spec.
 * @param {lifecycleManager.variableResolver} resolver - Resolver for looking up handler specifications
 * @param {lifecycleManager.userSession.localResolver} localResolver - Resolver for expanding configuration file paths
 * from the solutions registry.
 * @param {Object} solutions - Solutions registry entries for solutions available on the current machine.
 * @param {Object} options - Extra options for processing.
 * @param {Array} options.solutionsList - If provided, only solutions in this list of `solutionsID`s will
 * be captures. Example:
 *
 * '''json
 * ["com.microsoft.windows.cursors", "com.freedomscientific.jaws"]
 * '''
 * @return {fluid.promise} Returns a promise resolving with the entire system settings capture.
 */
gpii.flowManager.captureSystemSettings = function (invokeSettingsHandlerGet, resolver, localResolver, solutions, options) {
    var promiseTogo = fluid.promise();

    var handlerGetPromises = [];

    var safeHandlerGet = function (invokeSettingsHandlerGet, solutionID, handlerSpec) {
        var promiseTogo = fluid.promise();
        try {
            invokeSettingsHandlerGet(solutionID, handlerSpec).then(function (data) {
                // Fix up the nativeWindows and SPI Settings Handlers
                var filteredData = gpii.flowManager.filterInvokeSettingsHandlersReturn(data, handlerSpec);
                promiseTogo.resolve(filteredData);
            }, function (err) {
                promiseTogo.resolve({
                    solutionId: solutionID,
                    handlerSpec: handlerSpec,
                    isError: true,
                    message: "inner promise error",
                    err: err
                });
            });
        }
        catch (err) {
            promiseTogo.resolve({
                solutionId: solutionID,
                handlerSpec: handlerSpec,
                isError: true,
                message: "outer try error",
                err: err
            });
        }
        return promiseTogo;
    };

    var solutionsToFetch = solutions;
    if (options.solutionsList) {
        solutionsToFetch = {};
        fluid.each(solutions, function (solution, solutionID) {
            if (options.solutionsList.indexOf(solutionID) >= 0) {
                solutionsToFetch[solutionID] = solution;
            }
        });
    }

    fluid.each(solutionsToFetch, function (solution, solutionID) {
        var newSolution = gpii.lifecycleManager.transformSolutionSettings(solution, gpii.settingsHandlers.changesToSettings);

        if (solutionID === "com.freedomscientific.jaws") {
            newSolution = gpii.flowManager.jawsVoiceProfileAdjustment(newSolution, localResolver);
        }

        fluid.each(newSolution.settingsHandlers, function (handlerSpec) {
            //if applicationSettings is unspecified, dont attempt to get settings
            if (!handlerSpec.supportedSettings) {
                return;
            }
            handlerSpec.settings = handlerSpec.supportedSettings;
            // TODO GPII-228 This is temporary debugging code while we work through
            // the processing that is missing from this chain that transforms the paths
            // in capabilitiesTransforms to the schema information needed for the settings
            // handler
            if (handlerSpec.type === "gpii.windows.spiSettingsHandler") {
                fluid.each(handlerSpec.settings, function (handler, handlerKey) {
                    if (handlerSpec.capabilitiesTransformations[handlerKey].path.transform) {
                        handlerSpec.settings[handlerKey].path =
                            handlerSpec.capabilitiesTransformations[handlerKey].path.transform.input;
                    };
                    if (handlerSpec.capabilitiesTransformations[handlerKey].path.literalValue) {
                        handlerSpec.settings[handlerKey].path =
                            handlerSpec.capabilitiesTransformations[handlerKey].path.literalValue;
                    };
                });
            }
            handlerSpec = resolver.resolve(handlerSpec, {});
            handlerGetPromises.push(safeHandlerGet(invokeSettingsHandlerGet, solutionID, handlerSpec));
        });
    });
    var promisesSequence = fluid.promise.sequence(handlerGetPromises);
    promisesSequence.then(function (responses) {

        var finalPayload = gpii.flowManager.formatRawCapturedSettings(responses);
        promiseTogo.resolve(finalPayload);
    }, function (responses) {
        promiseTogo.resolve(responses);
    });

    return promiseTogo;
};

/**
 * The raw return payload from the capture promise sequence looks like:
 * '''json
 *       [
 *           {
 *               "fakemag1": [
 *                   {
 *                       "settings": {
 *                           "magnification": 2
 *                       }
 *                   }
 *               ]
 *           },
 *           {
 *               "fakemag1": [
 *                   {
 *                       "settings": {
 *                           "invert": true
 *                       }
 *                   }
 *               ]
 *           },
 *           {
 *               "fakemag2": [
 *                   {
 *                       "settings": {
 *                           "magnification": 2,
 *                           "invert": true
 *                       }
 *                   }
 *               ]
 *           }
 *       ]
 * '''
 *
 * and we want:
 * '''json
 *       {
 *           "fakemag1": {
 *               "magnification": 2,
 *               "invert": true
 *           },
 *           "fakemag2": {
 *               "magnification": 2,
 *               "invert": true
 *           }
 *       }
 * '''
 *
 * @param {Object} data - The raw captured data.
 * @return {Object} Returns a new payload with collapsed data, and multiple settings handler
 * results for the same solution merged together.
 */
gpii.flowManager.formatRawCapturedSettings = function (data) {
    var togo = {};
    fluid.each(data, function (sequenceItem) {
        if (sequenceItem.isError) {
            fluid.log("Error capturing settings for: ", sequenceItem);
            return;
        }
        fluid.each(sequenceItem, function (item, key) {
            if (!togo[key]) {
                togo[key] = {};
            }
            fluid.each(item[0].settings, function (value, settingId) {
                togo[key][settingId] = value;
            });
        });
    });
    return togo;
};

/**
 * JAWS Voice Profile Adjustment GPII-4146
 *
 * When applying settings to a machine we create our own Voice Profile to use, which is
 * hardcoded in the solutions registry as `GPII`. However, when capturing JAWS settings
 * we want to use whatever the default voice profile is, if there is one. More so, if there
 * is not a default voice profile, or a factory default is in use, we want to ignore the
 * voice profile configuration.
 *
 * Note: While the JAWS solution entry is fairly stable, if there are changes to the settings
 * configuration names, this will need to be updated.
 *
 * @param {Object} handlerSpec - The solutions registry entry for JAWS
 * @param {Function} localResolver - The localResolver, usually from the `userSession` on the
 * `lifecycleManager` to resolve the INI configuration paths where JAWS stores it's settings.
 * @return {Object} Returns a new handlerSpec with the configurations adjusted depending on the
 * current default voice profile on the system. This is a deep copy of `handlerSpec` the original
 * is not modified.
 */
gpii.flowManager.jawsVoiceProfileAdjustment = function (handlerSpec, localResolver) {
    var togo = fluid.copy(handlerSpec);

    // Configuration1 contains the path to the default settings stored in INI format
    var defaultJCFpath = localResolver(handlerSpec.settingsHandlers.configuration1.options.filename);
    var defaultJAWsSettings = gpii.iniFile.readFile(defaultJCFpath, {});

    // It's possible to not have a current voice profile set in DEFAULT.JCF
    // In the DEFAULT.JCF file it is stored here:
    // ```ini
    // [Voice Profiles]
    // ActiveVoiceProfileName=GPII
    // ```
    var currentVoiceProfile = false;
    if (defaultJAWsSettings["Voice Profiles"] && defaultJAWsSettings["Voice Profiles"].ActiveVoiceProfileName) {
        currentVoiceProfile = defaultJAWsSettings["Voice Profiles"].ActiveVoiceProfileName;
    }

    // Again this will need to be updated in sync with JAWS support. As of now, we don't store this path by itself in the
    // solution entry.
    var voiceProfilesDir = localResolver("${{environment}.APPDATA}\\Freedom Scientific\\JAWS\\2019\\Settings\\VoiceProfiles\\");
    var voiceProfilesPath = voiceProfilesDir + currentVoiceProfile + ".VPF";
    var voiceProfileExists = fs.existsSync(voiceProfilesPath);

    if (!voiceProfileExists) {
        // If the voice profile does not exist delete the second configuration from the
        // handlerSpec. The INI settings handler will fail for both configurations if the
        // file is missing.
        delete togo.settingsHandlers.configuration2;
    }
    else {
        // Otherwise update the .VPC ini configuration with the voice profile path
        togo.settingsHandlers.configuration2.options.filename = voiceProfilesPath;
    }

    return togo;
};

/**
 * This makes adjustments (hacks really) for the return payload of certain settings handlers,
 * which when invoked return the value of the setting in a separate sub-structure, rather than
 * as the direct proper of the settings block.  This should be temporary, and we should resolve
 * why the SPI and Native Settings Handler snapshots come back as (technically) generic capability
 * versions, rather than the transformed app specific settings like the rest of the settings
 * handlers.
 *
 *     "com.microsoft.windows.magnifier": [
 *      {
 *           "settings": {
 *               "Magnification": 200
 *           }
 *       }
 *   ]
 *
 *     "com.microsoft.windows.mouseSettings": [
 *       {
 *           "settings": {
 *               "DoubleClickWidthConfig": {
 *                   "value": 4
 *               }
 *           }
 *       }
 *   ]
 *
 *       "com.microsoft.windows.mouseSettings": [
 *       {
 *           "settings": {
 *               "ScrollWheelModeConfig": {
 *                   "value": 3,
 *                   "path": {
 *                       "get": "pvParam",
 *                       "set": "uiParam"
 *                   }
 *               }
 *           }
 *       }
 *   ]
 */
gpii.flowManager.filterInvokeSettingsHandlersReturn = function (data, handlerSpec) {
    if (handlerSpec.type === "gpii.windows.spiSettingsHandler" ||
        handlerSpec.type === "gpii.windows.nativeSettingsHandler") {
            var togo = fluid.copy(data);
            fluid.each(togo, function (appSettingHandlerArray, appId) {
                fluid.each(appSettingHandlerArray, function (settingsBlock) {
                    fluid.each(settingsBlock.settings, function (settingsData, settingsKey) {
                        settingsBlock.settings[settingsKey] = settingsData.value;
                    });
                })
            });
            return togo;
    }
    else {
        return data;
    }
};
