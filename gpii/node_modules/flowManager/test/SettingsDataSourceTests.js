/*!
GPII Settings Data Source

Copyright 2017 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    kettle = require("kettle"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    nock = require("nock");

require("flowManager");
// To reuse gpii.tests.oauth2.invokePromiseProducer()
fluid.require("%universal/gpii/node_modules/gpii-oauth2/gpii-oauth2-datastore/test/js/DataStoreTestsUtils.js");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.settingsDataSource");

gpii.tests.settingsDataSource.hostname = "http://gpii.net";
gpii.tests.settingsDataSource.accessTokenUrl = "/access_token";
gpii.tests.settingsDataSource.untrustedSettingsUrl = "/%userToken/untrusted-settings/%device";
gpii.tests.settingsDataSource.userToken = "gpii-token-test";
gpii.tests.settingsDataSource.device = {
    "OS": "windows 10"
};

gpii.tests.settingsDataSource.testCases = {
    nockConfig: {
        accessToken: {
            url: gpii.tests.settingsDataSource.accessTokenUrl,
            data: {
                "grant_type": "password",
                "password": "dummy",
                "client_id": "pilot-computer",
                "client_secret": "pilot-computer-secret",
                "username": gpii.tests.settingsDataSource.userToken
            },
            status: 200,
            response: {
                access_token: "access-token-test-in-settingsDataSource",
                expiresIn: 3600,
                token_type: "Bearer"
            }
        },
        untrustedSettings: {
            url: fluid.stringTemplate(gpii.tests.settingsDataSource.untrustedSettingsUrl, {
                userToken: gpii.tests.settingsDataSource.userToken,
                device: encodeURIComponent(JSON.stringify(gpii.tests.settingsDataSource.device))
            }),
            authHeader: {
                header: "Authorization",
                value: /Bearer .*/
            },
            status: 200,
            response: {
                settings: "user settings in success"
            }
        }
    }
};

// Set up mock ajax responses
gpii.tests.settingsDataSource.setupNock = function (config) {
    var cloudMock = nock(gpii.tests.settingsDataSource.hostname);

    // log nock matches
    cloudMock.log(console.log);

    // mock POST requests to "/access_token"
    cloudMock.post(config.accessToken.url, config.accessToken.data)
        .reply(config.accessToken.status, config.accessToken.response);
    // mock GET requests to "/untrusted-settings"
    cloudMock.get(config.untrustedSettings.url)
        .matchHeader(config.untrustedSettings.authHeader.header, config.untrustedSettings.authHeader.value)
        .reply(config.untrustedSettings.status, config.untrustedSettings.response);
};

gpii.tests.settingsDataSource.cleanNock = function () {
    nock.cleanAll();
};

// The customized settingsDataSource component for tests
fluid.defaults("gpii.tests.settingsDataSource", {
    gradeNames: ["gpii.flowManager.untrusted.settingsDataSource"],
    untrustedSettingsUrl: gpii.tests.settingsDataSource.hostname + gpii.tests.settingsDataSource.untrustedSettingsUrl,
    accessTokenUrl: gpii.tests.settingsDataSource.hostname + gpii.tests.settingsDataSource.accessTokenUrl,
    clientCredentialFilePath: "%universal/gpii/node_modules/flowManager/test/data/clientCredential-correct.json",
    listeners: {
        "onDestroy.cleanNock": "gpii.tests.settingsDataSource.cleanNock"
    }
});

// The base testEnvironment grade to be inherited by all tests
fluid.defaults("gpii.tests.settingsDataSourceTests", {
    gradeNames: ["fluid.test.testEnvironment"],
    settingsDataSourceGrade: "gpii.tests.settingsDataSource",   // supplied by individual tests
    testCaseHolderGrade: null,   // supplied by individual tests
    distributeOptions: {
        settingsDataSourceGrade: {
            source: "{that}.options.settingsDataSourceGrade",
            target: "{that > settingsDataSource}.type"
        },
        testCaseHolderGrade: {
            source: "{that}.options.testCaseHolderGrade",
            target: "{that > testCaseHolder}.type"
        }
    },
    components: {
        settingsDataSource: {
            type: "gpii.tests.settingsDataSource"
        },
        testCaseHolder: {
            type: "fluid.test.testCaseHolder"
        }
    }
});

// The base testCaseHolder grade to be inherited by test case holders used by all tests
fluid.defaults("gpii.tests.settingsDataSource.testCaseHolder", {
    gradeNames: "fluid.test.testCaseHolder",
    events: {
        onResponse: null,
        onError: null
    }
});

// 1. No saved access token: retrieve and save an access token that then is used to retrieve user settings
fluid.defaults("gpii.tests.settingsDataSource.testCaseHolder.noSavedAccessToken", {
    gradeNames: "gpii.tests.settingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with undefined initial access token: an access token is requested, saved and used to retrieve user settings",
        expect: 4,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                funcName: "gpii.tests.settingsDataSource.setupNock",
                args: [gpii.tests.settingsDataSource.testCases.nockConfig]
            }, {
                func: "jqUnit.assertDeepEq",
                args: ["No saved access token", {}, "{settingsDataSource}.accessTokens"]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{settingsDataSource}.get", [gpii.tests.settingsDataSource.userToken, gpii.tests.settingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertValue",
                args: ["The access token is received and saved", "{settingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertValue",
                args: ["The expiresIn is received and saved", "{settingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.settingsDataSourceTests.noSavedAccessToken", {
    gradeNames: ["gpii.tests.settingsDataSourceTests"],
    testCaseHolderGrade: "gpii.tests.settingsDataSource.testCaseHolder.noSavedAccessToken"
});

// 2. Has unexpired access token: use saved access token to retrieve user settings
fluid.defaults("gpii.tests.settingsDataSource.validSavedAccessToken", {
    gradeNames: ["gpii.tests.settingsDataSource"],
    members: {
        accessTokens: {
            "gpii-token-test": {
                accessToken: "a-valid-initial-access-token",
                timestampExpires: new Date(new Date().getTime() + 3600 * 1000).toISOString()  // expires in 1 hour
            }
        }
    }
});

fluid.defaults("gpii.tests.settingsDataSource.testCaseHolder.validSavedAccessToken", {
    gradeNames: "gpii.tests.settingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with a valid saved access token: the saved access token is used to retrieve user settings",
        expect: 5,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                funcName: "gpii.tests.settingsDataSource.setupNock",
                args: [gpii.tests.settingsDataSource.testCases.nockConfig]
            }, {
                func: "gpii.tests.settingsDataSource.assertInitialAccessToken",
                args: ["{that}", "{settingsDataSource}", false]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{settingsDataSource}.get", [gpii.tests.settingsDataSource.userToken, gpii.tests.settingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertEquals",
                args: ["The saved access token is same as the initial saved value", "{that}.initialSavedAccessToken", "{settingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertEquals",
                args: ["The saved timestampExpires is same as the initial saved value", "{that}.initialSavedTimestampExpires", "{settingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.settingsDataSourceTests.validSavedAccessToken", {
    gradeNames: ["gpii.tests.settingsDataSourceTests"],
    settingsDataSourceGrade: "gpii.tests.settingsDataSource.validSavedAccessToken",
    testCaseHolderGrade: "gpii.tests.settingsDataSource.testCaseHolder.validSavedAccessToken"
});

// 2. Has unexpired access token: use saved access token to retrieve user settings
fluid.defaults("gpii.tests.settingsDataSource.expiredSavedAccessToken", {
    gradeNames: ["gpii.tests.settingsDataSource"],
    members: {
        accessTokens: {
            "gpii-token-test": {
                accessToken: "a-valid-initial-access-token",
                timestampExpires: new Date(new Date().getTime() - 10 * 1000).toISOString()  // already expired 10 secs ago
            }
        }
    }
});

fluid.defaults("gpii.tests.settingsDataSource.testCaseHolder.expiredSavedAccessToken", {
    gradeNames: "gpii.tests.settingsDataSource.testCaseHolder",
    modules: [{
        name: "A workflow with expired saved access token: a new access token is requested, saved and used to retrive user settings",
        expect: 5,
        tests: [{
            name: "Settings received with the initial new token being fetched and saved",
            sequence: [{
                funcName: "gpii.tests.settingsDataSource.setupNock",
                args: [gpii.tests.settingsDataSource.testCases.nockConfig]
            }, {
                func: "gpii.tests.settingsDataSource.assertInitialAccessToken",
                args: ["{that}", "{settingsDataSource}", true]
            }, {
                func: "gpii.tests.oauth2.invokePromiseProducer",
                args: ["{settingsDataSource}.get", [gpii.tests.settingsDataSource.userToken, gpii.tests.settingsDataSource.device], "{that}"]
            }, {
                listener: "jqUnit.assertValue",
                args: ["The user settings are received", "{arguments}.0.settings"],
                event: "{that}.events.onResponse"
            }, {
                func: "jqUnit.assertNotEquals",
                args: ["The saved access token is different from the initial saved value", "{that}.initialSavedAccessToken", "{settingsDataSource}.accessTokens.gpii-token-test.accessToken"]
            }, {
                func: "jqUnit.assertNotEquals",
                args: ["The saved timestampExpires is different from the initial saved value", "{that}.initialSavedTimestampExpires", "{settingsDataSource}.accessTokens.gpii-token-test.timestampExpires"]
            }]
        }]
    }]
});

fluid.defaults("gpii.tests.settingsDataSourceTests.expiredSavedAccessToken", {
    gradeNames: ["gpii.tests.settingsDataSourceTests"],
    settingsDataSourceGrade: "gpii.tests.settingsDataSource.expiredSavedAccessToken",
    testCaseHolderGrade: "gpii.tests.settingsDataSource.testCaseHolder.expiredSavedAccessToken"
});

// Shared utility functions
gpii.tests.settingsDataSource.assertInitialAccessToken = function (that, settingsDataSource, isExpired) {
    var initialAccessToken = fluid.get(settingsDataSource, ["accessTokens", gpii.tests.settingsDataSource.userToken, "accessToken"]);
    var initialTimestampExpires = fluid.get(settingsDataSource, ["accessTokens", gpii.tests.settingsDataSource.userToken, "timestampExpires"]);

    jqUnit.assertValue("A saved access token is in place", initialAccessToken);
    jqUnit[isExpired ? "assertTrue" : "assertFalse"]("A saved access token is not expired", gpii.oauth2.getExpiresIn(new Date(), initialTimestampExpires) === 0);
    that.initialSavedAccessToken = initialAccessToken;
    that.initialSavedTimestampExpires = initialTimestampExpires;
};

// Run all tests
fluid.test.runTests([
    "gpii.tests.settingsDataSourceTests.noSavedAccessToken",
    "gpii.tests.settingsDataSourceTests.validSavedAccessToken",
    "gpii.tests.settingsDataSourceTests.expiredSavedAccessToken"
]);
