/*
 * GPII Flow Manager Save Tests
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    kettle = require("kettle"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs");

require("universal");

kettle.loadTestingSupport();

fluid.registerNamespace("gpii.tests.userSave");

gpii.tests.userSave.configRecord = {
    configName: "gpii.flowManager.tests.save.config",
    configPath: "%flowManager/test/configs"
};

gpii.tests.userSave.testToken1 = "testToken1";
gpii.tests.userSave.prefsDir = kettle.module.resolvePath("%universal/testData/preferences/");
gpii.tests.userSave.testToken1Set = {
    test: "test"
};

gpii.tests.userSave.filesToDelete = [];

gpii.tests.userSave.cleanUpTmpFiles = function () {
    fluid.each(gpii.tests.userSave.filesToDelete, function (filePath) {
        fs.unlinkSync(filePath);
    });
    gpii.tests.userSave.filesToDelete.length = 0;
};

gpii.tests.userSave.testSaveResponse = function (dataText) {
    var data = JSON.parse(dataText);
    var filePath = gpii.tests.userSave.prefsDir + data.userToken + ".json";
    gpii.tests.userSave.filesToDelete.push(filePath);
    jqUnit.assertDeepEq("Response is correct", gpii.tests.userSave.testToken1Set, data.preferences);
    var savedPrefs = require(filePath);
    jqUnit.assertDeepEq("Saved preferences are correct", gpii.tests.userSave.testToken1Set,
        savedPrefs.flat);
};

gpii.tests.userSave.triggerFailure = function () {
    fluid.builtinFail(["This failure is expected (flow manager save tests)"]);
};

gpii.tests.userSave.testBadResponse = function (data) {
    data = JSON.parse(data);
    console.log("GOT DATA ", data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertTrue("Message is correct",
        data.message.indexOf("This failure is expected") > -1);
};

fluid.defaults("gpii.tests.userSave.failingDataSource", {
    gradeNames: ["fluid.component"],
    readOnlyGrade: "gpii.tests.userSave.failingDataSource",
    invokers: {
        set: {
            funcName: "gpii.tests.userSave.failingDataSource.set"
        }
    }
});

gpii.tests.userSave.failingDataSource.set = function () {
    console.log("TRIGGERING FAILURE");
    // This method is made asynchronous on purpose, to try to evade the
    // exception handler inside route.js in connect.
    process.nextTick(kettle.wrapCallback(gpii.tests.userSave.triggerFailure));
    return fluid.promise();
};

gpii.tests.userSave.pushInstrumentedErrors = function () {
    // Restore Kettle's default uncaught exception handler (beating jqUnit's) so that we can test it
    fluid.onUncaughtException.addListener(kettle.requestUncaughtExceptionHandler, "fail", null,
        fluid.handlerPriorities.uncaughtException.fail);
};

gpii.tests.userSave.popInstrumentedErrors = function () {
    // restore jqUnit's exception handler for the next test
    fluid.onUncaughtException.removeListener("fail");
};


fluid.defaults("gpii.tests.userSave.rejectedPromise", {
    gradeNames: ["fluid.component"],
    invokers: {
        set: {
            funcName: "gpii.tests.userSave.rejectedPromise.set"
        }
    }
});

gpii.tests.userSave.rejectedPromise.set = function () {
    var promise = fluid.promise();
    promise.reject({
        isError: true,
        message: "this is a failure"
    });
    return promise;
};

gpii.tests.userSave.testRejectedResponse = function (request) {
    return function (data) {
        data = JSON.parse(data);
        jqUnit.assertTrue("Received error as expected", data.isError);
        jqUnit.assertEquals("Received message as expected", "this is a failure", data.message);
        jqUnit.assertEquals("Received error code 500", 500, request.nativeResponse.statusCode);
    };
};


var testDefs = [{
    name: "Flow Manager save tests",
    expect: 4,
    config: gpii.tests.userSave.configRecord,
    listeners: {
        onDestroy: "gpii.tests.userSave.cleanUpTmpFiles"
    },
    components: {
        saveRequest: { // TODO: this test is faulty - a PUT should be supplied for an existing user token
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort", // TODO: We would like to remove this duplication, it depends on FLUID-5495
                path: "/user/preferences/%userToken",
                method: "PUT",
                termMap: {
                    userToken: gpii.tests.userSave.testToken1
                }
            }
        },
        saveRequestNoToken: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        func: "{saveRequest}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequest}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }, {
        func: "{saveRequestNoToken}.send",
        args: gpii.tests.userSave.testToken1Set
    }, {
        event: "{saveRequestNoToken}.events.onComplete",
        listener: "gpii.tests.userSave.testSaveResponse"
    }]
}, {
    name: "Flow Manager failed save tests",
    expect: 2,
    config: gpii.tests.userSave.configRecord,
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    distributeOptions: {
        record: "gpii.tests.userSave.failingDataSource",
        target: "{that preferencesDataSource}.type",
        priority: "after:flowManager.development.prefs"
    },
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        funcName: "kettle.test.pushInstrumentedErrors",
        args: kettle.requestUncaughtExceptionHandler
    }, {
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listener: "gpii.tests.userSave.testBadResponse"
    }, {
        func: "kettle.test.popInstrumentedErrors"
    }]
}, {
    name: "PreferencesDataSource promise rejection",
    expect: 3,
    config: gpii.tests.userSave.configRecord,
    listeners: {
        onDestroy: gpii.tests.userSave.cleanUpTmpFiles
    },
    distributeOptions: {
        record: "gpii.tests.userSave.rejectedPromise",
        target: "{that preferencesDataSource}.type",
        priority: "after:flowManager.development.prefs"
    },
    components: {
        failRequest: {
            type: "kettle.test.request.http",
            options: {
                port: "{configuration}.options.mainServerPort",
                path: "/user/preferences",
                method: "POST"
            }
        }
    },
    sequence: [{
        func: "{failRequest}.send"
    }, {
        event: "{failRequest}.events.onComplete",
        listenerMaker: "gpii.tests.userSave.testRejectedResponse",
        makerArgs: [ "{failRequest}" ]
    }]
}];

module.exports = kettle.test.bootstrapServer(testDefs);
