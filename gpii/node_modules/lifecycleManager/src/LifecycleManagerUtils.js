/*!
 * Lifecycle Manager
 *
 * Copyright 2019 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion");
var gpii = fluid.registerNamespace("gpii");

(function () {
    /*
     * Remove settings that are not in the matchMaker settings results.
     * @param {Array} settingValues - An array of objects with each object keyed by a solution id with its value being
     * an object of setting values that this solution supports.
     * @param {Object} matchMakerSolutionRegistryEntries - The solution registry entries in the calculated lifecyle
     * instructions. Each solution registry entry contains a list of settings generated by a matchmaking process.
     * @return {Object} An object with each element keyed by a solution id with its value only having settings
     * generated by a matchmaking process.
     */
    gpii.lifecycleManager.getMatchMakerSettings = function (settingValues, matchMakerSolutionRegistryEntries) {
        var settingsTogo = {};
        // 1. collect all settings generated from the a matchmaking process
        var matchedSettingsForSolutions = {};
        fluid.each(matchMakerSolutionRegistryEntries, function (solutionSpec, solutionId) {
            var matchedSettings = [];
            fluid.each(solutionSpec.settingsHandlers, function (settingsHandlerSpec) {
                matchedSettings = matchedSettings.concat(fluid.keys(settingsHandlerSpec.settings));
            });
            fluid.set(matchedSettingsForSolutions, [solutionId], matchedSettings);
        });

        // 2. remove setting values that are not in matchedSettings
        fluid.each(settingValues, function (oneSolutionBlock) {
            fluid.each(oneSolutionBlock, function (settingBlocks, solutionId) {
                fluid.each(settingBlocks, function (oneSettingBlock) {
                    fluid.each(oneSettingBlock.settings, function (value, key) {
                        if (matchedSettingsForSolutions[solutionId].includes(key)) {
                            fluid.set(settingsTogo, [solutionId, key], value);
                        };
                    });
                });
            });
        });
        return settingsTogo;
    };

    /*
     * If a settingsHandler's "capabilitiesTransformations" block has a "noMatch" block defined, this setting will
     * always be returned even if it isn't a match for the requested preferences. This function is to remove this
     * kind of settings.
     * @param {Object} settingValues - A collection of objects with each object keyed by a solution id with its value
     * being an object of setting values that this solution supports.
     * @param {Object} preference - The preference that the removal is calculated for.
     * the "settingValues".
     * @param {Object} solutionRegistryEntries - The solution registry entries for the solutions in
     * the "settingValues".
     * @return {Object} An object in the same structure with settingValues but having unnecessary settings removed.
     */
    gpii.lifecycleManager.removeNoMatchSettings = function (settingValues, preference, solutionRegistryEntries) {
        var settingsTogo = {};
        var demandedPrefPaths = gpii.transformer.computeDemandedSettingsPaths(preference);
        fluid.each(settingValues, function (settings, solutionId) {
            fluid.each(settings, function (settingValue, settingName) {
                var settingsHandlers = fluid.get(solutionRegistryEntries, [solutionId, "settingsHandlers"]);
                fluid.each(settingsHandlers, function (oneSettingsHandler) {
                    // find the "capabilitiesTransformations" block for request settings
                    var oneSettingCapabilitiesTransformation = fluid.get(oneSettingsHandler, ["capabilitiesTransformations", settingName]);
                    if (oneSettingCapabilitiesTransformation) {
                        // A matched setting satisfies one of these conditions:
                        // 1. One setting handler's "capabilitiesTransformations" block handles an inputPath
                        // that matches the preference;
                        // 2. One setting handler's "capabilitiesTransformations" block is a straight mapping between
                        // the setting and the preference. An example:
                        // "word-ribbon": "http://registry\\.gpii\\.net/applications/com\\.microsoft\\.office.word-ribbon"
                        var isMatched = fluid.isPrimitive(oneSettingCapabilitiesTransformation) ?
                                        demandedPrefPaths.includes(oneSettingCapabilitiesTransformation) :
                                        gpii.transformer.hasSupportedSettings([], oneSettingCapabilitiesTransformation, preference);
                        if (isMatched) {
                            fluid.set(settingsTogo, [solutionId, settingName], settingValue);
                        }
                    }
                });
            });
        });
        return settingsTogo;
    };

    /*
     * Inverse transform settings to common or application terms
     * @param {Object} settings - Settings keyed by solution ids.
     * @param {Object} solutionRegistryEntries - The solution registry entries.
     * the "settingValues".
     * @return {Object} An transformed object keyed by preference URLs.
     */
    gpii.lifecycleManager.transformSettingsToPrefs = function (settings, solutionRegistryEntries) {
        var transformed;
        fluid.each(settings, function (settingsForOneSolution, solutionId) {
            var settingsHandlers = fluid.get(solutionRegistryEntries, [solutionId, "settingsHandlers"]);
            fluid.each(settingsHandlers, function (handler) {
                transformed = fluid.extend({}, fluid.model.transformWithRules(settingsForOneSolution, gpii.getInverseRules(handler)));
            });
        });
        return transformed;
    };
})();
