/*!
 * User Logon Request
 *
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

/** Mediate between the dynamic collection of user logon request components and the lifecycleManager by maintaining
 * an index named "userLogonRequestIndex" mapping requestIds onto user logon request member names
 */

fluid.defaults("gpii.lifecycleManager.userLogonRequestIndexer", {
    gradeNames: "gpii.indexedDynamicComponent",
    components: {
        dynamicIndexTarget: "{gpii.lifecycleManager}"
    },
    dynamicIndexTargetPath: "userLogonRequestIndex",
    dynamicIndexKeyPath: "options.requestId"
});

/** One dynamic component of this type is constructed for each user logon request on the LifecycleManager.
 */
fluid.defaults("gpii.lifecycleManager.userLogon.request", {
    gradeNames: ["fluid.component"],
    requestId: null,        // A unique string, must be supplied by integrators
    gpiiKey: null,          // A GPII key, must be supplied by integrators
    requestPromise: null,   // A promise, must be supplied by integrators
    events: {
        onSuccess: null,
        onError: null
    },
    listeners: {
        "onSuccess.resolveRequestPromise": "{that}.options.requestPromise.resolve",
        "onError.rejectRequestPromise": {
            listener: "{that}.options.requestPromise.reject",
            priority: "after:handleErrors"
        }
    }
});

gpii.lifecycleManager.userLogon.request.handlerGrades = fluid.freezeRecursive({
    login: "gpii.lifecycleManager.loginRequest",
    logout: "gpii.lifecycleManager.logoutRequest"
});

gpii.lifecycleManager.userLogon.request.handle = function (that, logonState) {
    var gpiiKey = that.options.gpiiKey;
    if (gpiiKey === "reset") {
        that.handleResetGpiiKey();
    } else {
        that[logonState === "login" ? "loginUser" : "logoutUser"](gpiiKey);
    }
};

/** A variant of user logon request to handle key-in requests.
 */
fluid.defaults("gpii.lifecycleManager.loginRequest", {
    gradeNames: [
        "gpii.lifecycleManager.userLogon.request",
        "{lifecycleManager}.options.logonStateChangeHandler",
        "gpii.lifecycleManager.userLogonRequestIndexer"
    ],
    listeners: {
        "onCreate.loginUser": {
            listener: "gpii.lifecycleManager.userLogon.request.handle",
            args: ["{that}", "login"]
        }
    }
});

/** A variant of user logon request to handle key-out requests.
 */
fluid.defaults("gpii.lifecycleManager.logoutRequest", {
    gradeNames: [
        "gpii.lifecycleManager.userLogon.request",
        "gpii.flowManager.userLogonHandling.stateChangeHandler",
        "gpii.lifecycleManager.userLogonRequestIndexer"
    ],
    listeners: {
        "onCreate.logoutUser": {
            listener: "gpii.lifecycleManager.userLogon.request.handle",
            args: ["{that}", "logout"]
        }
    }
});

/*
 * The lifecycleManager logon request queue is used to hold the key-in and key-out requests.
 * The entries in the action queue are of the format:
 * {
 *     gpiiKey: {String},
 *     logonState: {String}  // enum: ["login", "logout"]
 * }
 * The action queue is run sequentially, and an item is considered "done" once the promise returned by the request
 * is resolved.
 */
gpii.lifecycleManager.addToUserLogonRequestQueue = function (that, queue, item) {
    var newItem = fluid.copy(item);
    newItem.requestId = fluid.allocateGuid();
    newItem.requestPromise = fluid.promise();
    queue.push(newItem);
    if (!that.isProcessingUserLogonRequestQueue) {
        that.processUserLogonRequestQueue();
    }
    return newItem.requestPromise;
};

gpii.lifecycleManager.processUserLogonRequestQueue = function (that, queue) {
    // mark that we're currently processing action queue
    that.isProcessingUserLogonRequestQueue = true;
    // pick first item and process
    var item = queue.shift();
    var gradeName = gpii.lifecycleManager.userLogon.request.handlerGrades[item.logonState];

    if (!gradeName) {
        fluid.fail("No handler grade found for user logon action - " + item.logonState);
    };

    that.events.onUserLogonRequestReceived.fire(gradeName, item.requestId, item.gpiiKey, item.requestPromise);

    item.requestPromise.then(function () {
        gpii.lifecycleManager.userLogon.request.end(that, item);
    }, function () {
        gpii.lifecycleManager.userLogon.request.end(that, item);
    });
};

gpii.lifecycleManager.userLogon.request.end = function (that, item) {
    var queue = that.userLogonRequestQueue;

    // process next item in action queue if it exists
    if (queue.length > 0) {
        that.processUserLogonRequestQueue(queue);
    } else {
        that.isProcessingUserLogonRequestQueue = false;
    }
    var userLogonRequestComponent = fluid.get(that, that.userLogonRequestIndex[item.requestId]);
    userLogonRequestComponent.destroy();
};
