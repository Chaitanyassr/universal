/*
 * eventLog Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal"),
    fs = require("fs"),
    os = require("os"),
    readline = require("readline");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.eventLog");

require("../src/eventLog.js");

var teardowns = [];

jqUnit.module("gpii.tests.eventLog", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.eventLog.testDefs = fluid.freezeRecursive([
    {
        // data object
        testData: {
            func: "log",
            args: ["module0", "event0", {"data0": "value0"}]
        },
        expected: {
            "module": "module0",
            "event": "event0",
            "data": {"data0": "value0"}
        }
    },
    {
        // no data
        testData: {
            func: "log",
            args: ["module1", "event1"]
        },
        expected: {
            "module": "module1",
            "event": "event1"
        }
    },
    {
        // data string
        testData: {
            func: "log",
            args: ["module2", "event2", "value2"]
        },
        expected: {
            "module": "module2",
            "event": "event2",
            "data": {"value": "value2"}
        }
    },
    {
        // data number
        testData: {
            func: "log",
            args: ["module3", "event3", 1234]
        },
        expected: {
            "module": "module3",
            "event": "event3",
            "data": {"value": 1234}
        }
    },
    {
        // empty data
        testData: {
            func: "log",
            args: ["module4", "event4", {}]
        },
        expected: {
            "module": "module4",
            "event": "event4",
            "data": {}
        }
    },
    {
        // null data
        testData: {
            func: "log",
            args: ["module5", "event5", null]
        },
        expected: {
            "module": "module5",
            "event": "event5",
            "data": null
        }
    },
    {
        // timerId
        testData: {
            func: "log",
            args: ["module6", "event6", {}, "timer-id1"]
        },
        expected: {
            "module": "module6",
            "event": "event6",
            "data": {}
        }
    },
    {
        // logTimed, timerId from previous
        testData: {
            func: "logTimed",
            args: ["module7", "event7", {}, "timer-id1"]
        },
        expected: {
            "module": "module7",
            "event": "event7",
            "data": {"time": 0}
        }
    },
    {
        // logTimed, unknown timerId
        testData: {
            func: "logTimed",
            args: ["module7", "event7", {}, "timer-unknown"]
        },
        expected: {
            "module": "module7",
            "event": "event7",
            "data": {"time": 0}
        }
    }
]);

jqUnit.asyncTest("eventLog.log test", function () {
    var tests = gpii.tests.eventLog.testDefs;

    jqUnit.expect(tests.length * 6);

    var logFile = os.tmpdir() + "/gpii-test-eventLog-" + Date.now();
    teardowns.push(function() {
        fs.unlinkSync(logFile);
    });

    gpii.eventLog.logFilePath = logFile;

    // Log the test data
    for (var n = 0; n < tests.length; n++) {
        var test = tests[n].testData;
        gpii.eventLog[test.func].apply(null, test.args);
    }

    var reader = readline.createInterface({
        input: fs.createReadStream(logFile)
    });

    // Inspect each line of the log, making sure each one parses into the expected object.
    var lineNumber = 0;
    reader.on("line", function (line) {
        console.log("Log line", lineNumber, line);

        if (lineNumber >= tests.length) {
            jqUnit.fail("Log file should not contain more data.");
            return;
        }

        jqUnit.assertTrue("Line should look like a JSON object", !!line.match(/^{.*}$/));
        var obj = JSON.parse(line);
        jqUnit.assertEquals("JSON should be an object", "object", typeof(obj));

        // The time property is tricky to predict precisely, so just make sure it parses to a time within 5 seconds.
        jqUnit.assertTrue("Log entry must have a time property", obj.hasOwnProperty("time"));
        var time = Date.parse(obj.time);
        jqUnit.assertFalse("time property should be a valid timestamp", isNaN(time));
        var ago = Date.now() - time;
        var recent = ago >= 0 && ago < 5000;
        jqUnit.assertTrue("time property should have been the current time", recent);
        delete obj.time;

        // Same for data.time
        if (obj.data && obj.data.hasOwnProperty("time")) {
            jqUnit.expect(2);
            jqUnit.assertTrue("data.time property should be >= 0", obj.data.time >= 0);
            jqUnit.assertTrue("data.time property shouldn't be more than 5 seconds", obj.data.time < 5000);
            obj.data.time = 0;
        }

        jqUnit.assertDeepEq("Parsed log should match expected", tests[lineNumber].expected, obj);

        lineNumber++;
    });
    reader.on("close", function (line) {
        jqUnit.start();
    });
});