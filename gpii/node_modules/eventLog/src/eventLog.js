/*
 * Event logging.
 * This acts upon events that are deemed interesting enough to be recorded and sent to a log server for analysis. The
 * log produced here is in JSON and sent to a different output than the usual fluid.log.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");
var fs = require("fs"),
    path = require("path");

var gpii = fluid.registerNamespace("gpii"),
    $ = fluid.registerNamespace("jQuery");

fluid.registerNamespace("gpii.eventLog");

fluid.defaults("gpii.eventLog", {
    gradeNames: ["fluid.component", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.eventLog.windows"
                }
            }
        }
    },
    components: {
        installID: {
            type: "gpii.installID"
        }
    },
    invokers: {
        // moduleName, event, data, [level]
        logEvent: "gpii.eventLog.log",
        defer: "gpii.eventLog.defer",
        logDeferred: "gpii.eventLog.logDeferred"
    },
    listeners: {
        "onCreate.installId": {
            func: "gpii.eventLog.setInstallId",
            args: ["@expand:{that}.installID.getInstallID()"]
        },
        "onCreate.log": {
            func: "{that}.logEvent",
            args: ["gpii", "Start", {}, "Stop"]
        },
        "onDestroy.logDeferred": {
            func: "{that}.logDeferred",
            args: []
        },
        "onDestroy.log": {
            func: "{that}.logEvent",
            args: ["gpii", "Stop", {}]
        },
        "{lifecycleManager}.events.onSessionStart": {
            namespace: "eventLog",
            func: "{that}.logEvent",
            args: [
                "lifecycle",
                "SessionStart",
                {userToken: "{arguments}.1.model.userToken"},
                "SessionStop"
            ]
        },
        "{lifecycleManager}.events.onSessionStop": {
            namespace: "eventLog",
            func: "{that}.logEvent",
            args: [
                "lifecycle",
                "SessionStop",
                {userToken: "{arguments}.1.model.userToken"}
            ]
        }
    }
});

/**
 * The timers for timed events.
 */
gpii.eventLog.timers = {};

/**
 * The outstanding log entries waiting for their duration.
 */
gpii.eventLog.pendingLogs = {};

/**
 * The log file.
 */
gpii.eventLog.logFilePath = null;

/**
 * The installation ID
 */
gpii.eventLog.installationID = null;

/**
 * Gets (and stores) the installation ID.
 * @param installationId The installation ID.
 */
gpii.eventLog.setInstallId = function (installationId) {
    gpii.eventLog.installationID = installationId;
};

/**
 * Returns the actual Date and time
 */
gpii.eventLog.getTimestamp = function () {
    return new Date();
};

/**
 * Creates an object for the log. Everything in this object is what will be logged, and the "time" field will be added
 * later when it is actually logged.
 *
 * @param moduleName {String} The part of GPII causing this event.
 * @param event {String} Name of the event.
 * @param data [optional] Event specific data.
 * @param linkId {String} [optional] An id to link two related events (eg, the start and stop of something).
 * @param level {Object} [optional] Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 * @return {Object} The log object.
 */
gpii.eventLog.createLogObject = function (moduleName, event, data, linkId, level) {
    if (!level && fluid.isLogLevel(linkId)) {
        level = linkId;
        linkId = null;
    }

    var eventObject = {
        module: moduleName || "GPII",
        event: event,
        level: level
    };

    if (linkId) {
        eventObject.link = linkId;
    }

    var dataWrapped = gpii.eventLog.wrapData(data);
    if (dataWrapped !== null) {
        eventObject.data = fluid.copy(dataWrapped);
    }
    return eventObject;
};

/**
 * Logs an event.
 *
 * If this event is the start of something (like "StartSession"), then fill in the closeEvent parameter to ensure it
 * gets logged even if GPII closes.
 *
 * @param moduleName {String} The part of GPII causing this event.
 * @param event {String} The event name.
 * @param data {Object} [optional] Event specific data.
 * @param closeEvent {Object} [optional] The name of the closing event, if this one was the start of something (like a
 * session).
 * @param level {Object} [optional] Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 */
gpii.eventLog.log = function (moduleName, event, data, closeEvent, level) {
    if (!level && fluid.isLogLevel(closeEvent)) {
        level = closeEvent;
        closeEvent = null;
    }

    var id = moduleName + "#" + event;
    if (gpii.eventLog.pendingLogs[id]) {
        // There's already a pending entry for this event
        gpii.eventLog.logDeferred(moduleName, event, data);
    } else {
        var linkId = null;
        if (closeEvent) {
            // Defer the close event, so it always gets called (and with the same linkId).
            linkId = gpii.eventLog.createLinkId();
            gpii.eventLog.defer(moduleName, closeEvent, data, linkId);
        }
        var eventObject = gpii.eventLog.createLogObject(moduleName, event, data, linkId, level);
        gpii.eventLog.writeLog(level, eventObject);
    }
};

/**
 * Create an ID to link two related events.
 */
gpii.eventLog.createLinkId = fluid.allocateGuid;

/**
 * Defers logging of an event until a later time (when logDeferred() same moduleName and event), or the application
 * exits). This ensures the event is always logged.
 *
 * @param moduleName {String} The part of GPII causing this event.
 * @param event {String} The event name.
 * @param data {Object} Event specific data.
 * @param linkId {String} [optional] An id to link two related events (eg, the start and stop of something).
 * @param level {Object} [optional] Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 */
gpii.eventLog.defer = function (moduleName, event, data, linkId, level) {
    if (!level && fluid.isLogLevel(linkId)) {
        level = linkId;
        linkId = null;
    }
    var id = moduleName + "#" + event;
    gpii.eventLog.pendingLogs[id] = gpii.eventLog.createLogObject(moduleName, event, data, linkId, level);
};

/**
 * Logs an entry that was previously called by defer().
 *
 * Calling with no parameters will log all deferred entries.
 *
 * @param moduleName {String} [Optional] The part of GPII causing this event.
 * @param event {String} [Optional] The event name.
 * @param data {Object} [Optional] Event specific data. This will be added onto the data object passed to defer().
 */
gpii.eventLog.logDeferred = function (moduleName, event, data) {
    if (arguments.length) {
        var id = moduleName + "#" + event;
        var eventObject = gpii.eventLog.pendingLogs[id];
        if (eventObject) {
            delete gpii.eventLog.pendingLogs[id];
            fluid.extend(eventObject.data, data);
            gpii.eventLog.writeLog(eventObject.level, eventObject);
        } else {
            fluid.log("logDeferred: Unknown deferred event", id);
        }
    } else {
        // Do all of them, LIFO.
        var events = fluid.flatten(gpii.eventLog.pendingLogs).reverse();
        fluid.each(events, function (eventObject) {
            gpii.eventLog.writeLog(eventObject.level, eventObject);
        });

        gpii.eventLog.pendingLogs = {};
    }
};

/**
 * Logs an error.
 *
 * @param moduleName {String} The part of GPII causing this error.
 * @param errType {String} Type of error.
 * @param err {Object} The error.
 */
gpii.eventLog.logError = function (moduleName, errType, err) {
    var data = {};
    if (err instanceof Error) {
        // Error doesn't serialise
        data.error = {};
        fluid.each(Object.getOwnPropertyNames(err), function (a) {
            data.error[a] = err[a];
        });
    } else {
        data.error = err;
    }
    gpii.eventLog.log(moduleName, "Error." + errType, data, fluid.logLevel.FAIL);
};

// Log uncaught exceptions.
fluid.onUncaughtException.addListener(function (err) {
    gpii.eventLog.logError(null, "UncaughtException", err);
}, "gpii-eventLog");

// Log fluid.fail.
fluid.failureEvent.addListener(function (args) {
    var err = Array.isArray(args) ? args.join(" ") : err;
    gpii.eventLog.logError(null, "Failure", err);
}, "gpii-eventLog", "before:fail");

/**
 * Gets the path of the new log file for this instance of gpii.
 *
 * @return {String} Path of the log file.
 */
gpii.eventLog.getLogFilePath = function () {
    if (!gpii.eventLog.logFilePath) {
        var startupTime = Date.now();
        gpii.eventLog.logFilePath = process.env.GPII_EVENT_LOG;

        if (!gpii.eventLog.logFilePath) {
            var settingsDirComponent = gpii.settingsDir();
            var gpiiSettingsDir = settingsDirComponent.getGpiiSettingsDir();
            gpii.eventLog.logFilePath =
                path.join(gpiiSettingsDir, "gpii-" + gpii.journal.formatTimestamp(startupTime) + ".log");
        }

        fluid.log(fluid.logLevel.IMPORTANT, "Writing event log to " + gpii.eventLog.logFilePath);
    }
    return gpii.eventLog.logFilePath;
};

/**
 * Writes an event to the log file.
 *
 * @param level {Object} Level of the log, see fluid.logLevelsSpec [FATAL,FAIL,WARN,IMPORTANT,INFO,TRACE].
 * @param event {Object} The object. This will be modified to what has been sent to the log.
 */
gpii.eventLog.writeLog = function (level, event) {
    var intLevel = gpii.eventLog.checkLevel(level);
    event.level = intLevel.value;

    fluid.logObjectRenderChars = 0xffffff;
    // Log to console before the installation ID and timestamp are added (no one wants to see it).
    fluid.log(fluid.logLevel.IMPORTANT, event);

    if (!gpii.eventLog.logFilePath) {
        gpii.eventLog.logFilePath = gpii.eventLog.getLogFilePath();
    }
    event.installID = gpii.eventLog.installationID;
    event.timestamp = gpii.eventLog.getTimestamp();
    fs.appendFileSync(gpii.eventLog.logFilePath, JSON.stringify(event) + "\n");
};

/**
 * Ensures a value is an object. If it's not an object, return an object containing it.
 * Null, empty object, or undefined returns null.
 *
 * @param data The value to work with.
 * @return {object} The given object, or new object with a field "value" set to data
 */
gpii.eventLog.wrapData = function (data) {
    var dataTogo;

    if (data === null || data === undefined) {
        dataTogo = null;
    } else if (fluid.isPlainObject(data, true)) {
        dataTogo = $.isEmptyObject(data) ? null : data;
    } else {
        dataTogo = {value: data};
    }

    return dataTogo;
};

/**
 * Ensure that the loglevel has a valid value. The levels are defined in the fluid.logLevelsSpec
 * Sets INFO as default loglevel
 *
 * @param level to check, can be a string that represents the value or a property of fluid.logLevel
 * @return a valid fluid.logLevel, with INFO as default
 */
gpii.eventLog.checkLevel = function (level) {
    if (typeof level === "string" && level in fluid.logLevelsSpec) {
        return fluid.logLevel[level];
    } else {
        return fluid.isLogLevel(level) ? level : fluid.logLevel.INFO;
    }
};

fluid.defaults("gpii.eventLog.log", {
    gradeNames: "fluid.function"
});
