/*
 * singleInstance Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal"),
    fs = require("fs"),
    os = require("os"),
    child_process = require("child_process");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.singleInstance");

require("singleInstance");

jqUnit.module("gpii.tests.singleInstance");

jqUnit.test("Testing checkInstance, registerGpiiInstance, and deregisterInstance", function () {

    var pidFile = os.tmpdir() + "/gpii-test-pid" + Date.now();

    // Start another process (a cross-platform "sleep"), to test against a live pid.
    var otherProcess = child_process.exec("node -e \"setTimeout(console.log, 5000)\"");

    var tests = [
        {
            // no pidfile
            testData: null,
            expected: {
                checkInstance: null,
                registerInstance: true,
                file: process.pid,
                deregisterInstance: false
            }
        },
        {
            // junk content
            testData: "not a pid",
            expected: {
                checkInstance: null,
                registerInstance: true,
                file: process.pid,
                deregisterInstance: false
            }
        },
        {
            // non-running pid
            testData: "-100",
            expected: {
                checkInstance: null,
                registerInstance: true,
                file: process.pid,
                deregisterInstance: false
            }
        },
        {
            // this process
            testData: process.pid,
            expected: {
                checkInstance: process.pid,
                registerInstance: true,
                file: process.pid,
                deregisterInstance: true
            }
        },
        {
            // another process
            testData: otherProcess.pid,
            expected: {
                checkInstance: otherProcess.pid,
                // If the implementation was complete, then registerInstance should succeed because the test process
                // isn't another GPII instance.
                registerInstance: false,
                file: otherProcess.pid,
                deregisterInstance: false
            }
        }
    ];

    var funcs = [ "checkInstance", "registerInstance", "deregisterInstance" ];

    var deletePidFile = function () {
        try {
            fs.unlinkSync(pidFile);
        } catch (e) {
            // Don't care if it failed, as long as it's gone.
            if (fs.existsSync(pidFile)) {
                throw e;
            }
        }
    };

    try {
        while (funcs.length > 0) {
            var func = funcs.shift();
            for (var n = 0; n < tests.length; n++) {
                var test = tests[n];
                // Set the pid file.
                if (test.testData === null) {
                    deletePidFile();
                } else {
                    fs.writeFileSync(pidFile, test.testData);
                }

                // Call the function
                var returnValue = gpii.singleInstance[func](pidFile);
                jqUnit.assertEquals(func + " return #" + n, test.expected[func], returnValue);

                if (func === "registerInstance") {
                    // Check the new pid file
                    var content = fs.readFileSync(pidFile, {encoding: "utf8"});
                    var value = parseInt(content);
                    jqUnit.assertEquals("registerInstance pidfile #" + n, test.expected.file, value);
                } else if (func === "deregisterInstance") {
                    if (returnValue) {
                        var exists = fs.existsSync(pidFile);
                        jqUnit.assertTrue("pidFile should not exist after a successful deregisterInstance", !exists);
                    }
                }

                deletePidFile();
            }
        }
    } finally {
        deletePidFile();
    }

});

jqUnit.test("Testing singleInstance end-to-end", function () {
    var pidFile = os.tmpdir() + "/gpii-test-pid" + Date.now();

    // perform an end-to-end test
    var pid = gpii.singleInstance.checkInstance(pidFile);
    jqUnit.assertEquals("Another instance should not be detected before registering", null, pid);

    var registered = gpii.singleInstance.registerInstance(pidFile);
    jqUnit.assertTrue("This instance should have been registered", registered);

    pid = gpii.singleInstance.checkInstance(pidFile);
    jqUnit.assertEquals("The current instance should be this one", process.pid, pid);

    var deregistered = gpii.singleInstance.deregisterInstance(pidFile);
    jqUnit.assertTrue("This instance should have been deregistered", deregistered);

    pid = gpii.singleInstance.checkInstance(pidFile);
    jqUnit.assertEquals("Another instance should not be detected after deregistering", null, pid);
});
