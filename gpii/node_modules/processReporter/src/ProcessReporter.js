/**
 * GPII Process Reporter
 *
 * Copyright 2015 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.require("kettle", require);
fluid.require("./processesBridge.js", require);

fluid.defaults("gpii.processReporter", {
    gradeNames: "fluid.component"
});

fluid.defaults("gpii.processReporter.base", {
    gradeNames: ["kettle.app", "gpii.processReporter"],
    requestHandlers: {
        processGet: {
            route: "/processes",
            type: "gpii.processReporter.allSolutions.get",
            method: "get"
        },
        processGetSingle: {
            route: "/processes/:solutionID",
            type: "gpii.processReporter.solution.get",
            method: "get"
        }
    },
    components: {
        platformReporter: {
            type: "gpii.platformReporter.native"
        },
        nameResolver: {
            type: "gpii.processReporter.nameResolver"
        }
    },
    invokers: {
        fireResponse: {
            funcName: "gpii.processReporter.fireResponse",
            args: ["{arguments}.0", "{arguments}.1", "{platformReporter}"]
                  // request, runningSolutions
        }
    }
});

fluid.defaults("gpii.processReporter.allSolutions.get", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            func: "{processReporter}.get",
            args: [
                "{request}"
            ]
        }
    }
});

fluid.defaults("gpii.processReporter.solution.get", {
    gradeNames: ["kettle.request.http"],
    invokers: {
        handleRequest: {
            func: "{processReporter}.getProcess",
            args: ["{request}", "{processReporter}", "{solutionsRegistryDataSource}"]
        }
    }
});

fluid.defaults("gpii.processReporter.nameResolver", {
    gradeNames: ["fluid.component"],
    invokers: {
        resolveName: {
            funcName: "fluid.identity"
        }
    }
});

gpii.processReporter.fireResponse = function (request, runningSolutions, platformReporter) {
    request.events.onSuccess.fire({
        solutions: runningSolutions,
        OS: platformReporter.reportPlatform()
    });
};

fluid.defaults("gpii.processReporter.static", {
    gradeNames: ["gpii.processReporter.base"],
    components: {
        runningSolutionsDataSource: {
            type: "kettle.dataSource.file",
            options: {
                gradeNames: "kettle.dataSource.file.moduleTerms"
            }
        }
    },
    invokers: {
        get: {
            funcName: "gpii.processReporter.static.get",
            args: ["{arguments}.0", "{processReporter}"]
        },
        getProcess: {
            funcName: "gpii.processReporter.static.getProcess",
            args: ["{arguments}.0", "{processReporter}"]
        }
    }
});

gpii.processReporter["static"].get = function (request, processReporter) {
    var promise = processReporter.runningSolutionsDataSource.get();
    promise.then(function (runningSolutions) {
        if (!fluid.isDestroyed(processReporter)) { // Remove check when FLUID-5790 is resolved.
            processReporter.fireResponse(request, runningSolutions);
        }
    }, function (err) {
        request.events.onError.fire({
            statusCode: 500,
            message: "Failed to read processReporter source. " + (err.message || err.error),
            isError: true
        });
    });
};

gpii.processReporter["static"].getProcess = function (request, processReporter) {
    var solutionID = request.req.params.solutionID;
    var promise = processReporter.runningSolutionsDataSource.get();
    promise.then(function () {
        if (!fluid.isDestroyed(processReporter)) { // Remove check when FLUID-5790 is resolved.
            processReporter.fireResponse(request, { id: solutionID, running: true });
        }
    }, function (err) {
        request.events.onError.fire({
            statusCode: 500,
            message: "Failed to read processReporter source. " + (err.message || err.error),
            isError: true
        });
    });
};

fluid.defaults("gpii.processReporter.live", {
    gradeNames: ["gpii.processReporter.base"],
    invokers: {
        get: {
            funcName: "gpii.processReporter.live.get",
            args: ["{arguments}.0", "{processReporter}", "{flowManager}.solutionsRegistryDataSource"]
        },
        getProcess: {
            funcName: "gpii.processReporter.live.getProcess",
            args: ["{arguments}.0", "{processReporter}", "{flowManager}.solutionsRegistryDataSource"]
        },
        handleIsRunning: {
            funcName: "gpii.processReporter.live.handleIsRunning",
            args: ["{arguments}.0"]
                   // entry
        }
    }
});

/* Marker function for use in isRunning sections of a launch handler
 * to identify in a meaningful way that the solutions start block should always
 * be run.
 */
fluid.defaults("gpii.processReporter.neverRunning", {
    gradeNames: "fluid.function",
    argumentMap: {}
});

gpii.processReporter.neverRunning = function () {
    return false;
};

/**
 * Runs the 'isRunning' entries of the 'entry' argument. If no 'isRunning' block is present
 * undefined is returned
 */
gpii.processReporter.live.handleIsRunning = function (entry) {
    var running = undefined;
    if (!!entry.isRunning) {
        running = true;
        fluid.each (entry.isRunning, function (aMember) {
            var partial = fluid.invokeGradedFunction(aMember.type, aMember);
            running = running && partial;
        });
    }
    return running;
};

gpii.processReporter.live.get = function (request, processReporter, solutionsRegistryDataSource) {
    var runningSolutions = [];
    solutionsRegistryDataSource.get({os: processReporter.platformReporter.reportPlatform().id}, function onSuccess(entries) {
        fluid.each(entries, function (entry) {
            var foundEntry = gpii.processReporter.live.handleIsRunning(entry);
            if  (foundEntry !== null) {
                runningSolutions.push(foundEntry);
            }
        });
        processReporter.fireResponse(request, runningSolutions);
    });
};

gpii.processReporter.live.getProcess = function (request, processReporter, solutionsRegistryDataSource) {
    var solutionID = request.req.params.solutionID;
    solutionsRegistryDataSource.get({os: processReporter.platformReporter.reportPlatform().id}, function onSuccess(entries) {
        var result = fluid.find(entries, function (anEntry, entryID) {
            if (entryID === solutionID) {
                return gpii.processReporter.live.handleIsRunning(anEntry);
            }
        }, null);
        if (result === null) {
            result = { id: solutionID, running: false };
        }
        processReporter.fireResponse(request, result);
    });
};

fluid.defaults("gpii.processReporter.dev", {
    gradeNames: ["kettle.urlExpander.distributeDevVariables"]
});
