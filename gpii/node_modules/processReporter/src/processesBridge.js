/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require */

"use strict";

var fluid = require("infusion");
var gpii = fluid.registerNamespace("gpii");

gpii.processes = fluid.registerNamespace("gpii.processes");

fluid.defaults("gpii.processes", {
    gradeNames: ["gpii.processes.native", "fluid.component"],
    invokers: {
        findSolutionsByCommands: {
            funcName: "gpii.processes.findSolutionsByCommands",
            args: ["{arguments}.0"]   // array of command names
        },
        findSolutionsByPids: {
            funcName: "gpii.processes.findSolutionsByPids",
            args: ["{arguments}.0"]   // array of pids (process ids)
        },
        findProcessByPid: {
            funcName: "gpii.processes.findProcessByPid",
            args: ["{arguments}.0", "{arguments}.1"] // pid, procArray (optional)
        },
        findProcessesByCommand: {
            funcName: "gpii.processes.findProcessesByCommand",
            args: ["{arguments}.0", "{arguments}.1"]
            // command, procArray (optional)
        },
        findFirstProcessByCommand: {
            funcName: "gpii.processes.findFirstProcessByCommand",
            args: ["{arguments}.0", "{arguments}.1"]
            // command, procArray (optional)
        },
        isRunning: {
            funcName: "gpii.processes.isRunning",
            args: ["{arguments}.0"]   // state (string)
        },
        updateProcInfo: {
            funcName: "gpii.processes.updateProcInfo",
            args: ["{arguments}.0"]   // process info structure
        },
        initProcInfoNotRunning: {
            funcName: "gpii.processes.initProcInfoNotRunning",
            args: ["{arguments}.0"]   // command name (string)
        }
    }
});

/**
 * Return a list of process information objects corresponding to the names
 * of each of the passed in commands.  If nothing is found, returns an empty
 * array.
 *
 * @param commandNames {Array} - the names of the processes to inspect.
 * @return {Array} - Array of procInfo objects for each command name.  Empty
 *                   if no processes are found.
 */
gpii.processes.findSolutionsByCommands = function (commandNames) {
    if (!!commandNames) {
        return fluid.accumulate(commandNames, function (aCommand, matches) {
            var procInfos = gpii.processes.findProcessesByCommand(aCommand);
            matches = matches.concat(procInfos);
            return matches;
        }, []);
    }
    else {
        return [];
    }
};

/**
 * Return an list of process information objects corresponding to the
 * pids (process id numbers) passed in.  If nothing is found, returns an empty
 * array.
 *
 * @param pids {Array} - the process ids of the processes to inspect.
 * @return {Array} - Array of procInfo objects for each pid.  Empty
 *                   if no corresponding processes are found.
 */
gpii.processes.findSolutionsByPids = function (pids) {
    if (!!pids) {
        return fluid.accumulate(pids, function (aPid, matches) {
            var found = gpii.processes.findProcessByPid(aPid);
            if (found !== null) {
                matches.push(found);
            }
            return matches;
        }, []);
    }
    else {
        return [];
    }
};

/**
 * Return a process information object corresponding to THE given process
 * id (process id number).  Returns null if there is no such process.
 *
 * @param pid {Number} - the process id of the processe to inspect.
 * @param procArray {Array} Optional - an array of process information
 *                                     objects to search.
 * @return {Object} - A proccess information object for the process with the
 *                    given id.  Returns null if there is no such process.
 */
gpii.processes.findProcessByPid = function (pid, procArray) {
    if (!procArray) {
        procArray = gpii.processes["native"].getProcessList(pid);
    }
    return fluid.find(procArray, function (procInfo) {
        if (procInfo.pid === pid) {
            return procInfo;
        }
    }, null);
};

/**
 * Return a list of process information objects that match the given
 * command name.  Return san empty array if not matching name is found.
 *
 * @param commandName {String} - the name of the processe to inspect.
 * @param procArray {Array} Optional - an array of process information
 *                                     objects to search.
 * @return {Object} - A proccess information object for the process with the
 *                    given id.  Returns null if there is no such process.
 */
gpii.processes.findProcessesByCommand = function (commandName, procArray) {
    if (!procArray) {
        procArray = gpii.processes["native"].getProcessList(commandName);
    }
    return fluid.accumulate(procArray, function (aProcInfo, matchingProcs) {
        if (aProcInfo.command === commandName) {
            matchingProcs.push(aProcInfo);
        }
        return matchingProcs;
    }, []);
};

/**
 * Return the first process of an array of processes all with the same
 * command name.  If there are no matching names, return null.
 *
 * @param commandName {String} - the name of the processe to inspect.
 * @param procArray {Array} Optional - an array of process information
 *                                     objects to search.
 * @return {Object} - A proccess information object for the process with the
 *                    given id, null if there is no such process.
 */
gpii.processes.findFirstProcessByCommand =
function (commandName, procArray) {
    var commands =
        gpii.processes.findProcessesByCommand(commandName, procArray);
    if (commands.length > 0) {
        return commands[0];
    }
    else {
        return null;
    }
};

// Map to reduce process state values into "Running" (= true) vs. "Not Running"
// (= false).
gpii.processes.stateToRunning = fluid.freezeRecursive({
    "Running": true,
    "Uninterruptible": true,
    "Sleeping": true,
    "Stopped": true,
    "Zombie": false,
    "NoSuchProcess": false
});

/**
 * Determine if a process is running based on its native state.
 *
 * @param state {String} - Native state of the process
 * @return {Boolean} - Returns true if the process is running, false otherwise.
 */
gpii.processes.isRunning = function (state) {
    return gpii.processes.stateToRunning[state];
};

/**
 * Renew the information about a process, or create a new "no such process"
 * information object.
 *
 * @param procInfo {Object} - Latest information about a process.
 * @return {Object} - Returns a new process information object about the process.
 */
gpii.processes.updateProcInfo = function (procInfo) {
    var newProcInfo = null;
    if (procInfo.state === "NoSuchProcess") {
        newProcInfo =
            gpii.processes.findFirstProcessByCommand(procInfo.command);
    }
    else {
        newProcInfo = gpii.processes.findProcessByPid(procInfo.pid);
    }
    if (newProcInfo === null) {
        newProcInfo =
            gpii.processes.initProcInfoNotRunning(procInfo.command);
    }
    return newProcInfo;
};

/**
 * Create process information object for a not-running process.
 *
 * @param command {String} - Name of the process.
 * @return {Object} - Returns a new process information object initialized as
 *                    if the process is not running.
 */

gpii.processes.initProcInfoNotRunning = function (command) {
    return fluid.freezeRecursive({
        "command": command,
        "pid": -1,
        "ppid": -1,
        "uid": -1,
        "gid": -1,
        "fullPath": "",
        "argv": "",
        "state": "NoSuchProcess"
    });
};
