/*!
GPII Settings Transformer

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013-2014 Raising the Floor

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.transformer");

(function () {
    /**
     * Helper function for `gpii.transformer.configurationToSettings`. Used to modify the settings handler
     * blocks to be in the format required (i.e. including the application specific settings to be
     * set) by the actual settings handlers. This modifies the block in place - it has already been copied by the
     * the caller
     *
     * @param {Object} settingsHandler - The settingsHandler information from the solutions registry to be transformed - MODIFIED IN PLACE.
     * @param {Object} oneUserSolution - The user preferences related to this solution and settings handler.
     * @param {Object} solutionId - The ID of the solution for which the settingshandler is related.
     * @return {Object} - The modified settingshandler object - ready to be passed to the lifecycle manager
     */
    gpii.transformer.transformOneSettingsHandler = function (settingsHandler, oneUserSolution, solutionId) {
        var settings = fluid.copy(oneUserSolution.settings["http://registry.gpii.net/applications/" + solutionId]);

        // extract any common terms that were defined in the application block and delete them from the settings block
        var scopedCommon = {};
        fluid.each(settings, function (val, key) {
            if (key.startsWith("http://registry.gpii.net/common/")) {
                scopedCommon[key] = fluid.copy(val); // add to list of scoped common terms
                delete settings[key]; // remove from the settings
            }
        });

        // filter to only keep relevant application specific settings
        settings = gpii.settingsHandlers.filterSupportedSettings(settings, settingsHandler.supportedSettings);

        if (settingsHandler.capabilitiesTransformations) {
            var inferred = fluid.model.transformWithRules(oneUserSolution.settings, settingsHandler.capabilitiesTransformations);
            var inferredScoped = (scopedCommon === undefined || $.isEmptyObject(scopedCommon)) ? {} : fluid.model.transformWithRules(scopedCommon, settingsHandler.capabilitiesTransformations);
            settings = fluid.extend(true, {}, inferred, inferredScoped, settings);
        }

        settingsHandler.settings = settings || {};
        delete settingsHandler.capabilitiesTransformations;
        delete settingsHandler.capabilities;
        return settingsHandler;
    };

    /**
     * Converts a system configuration (output from the context manager from matchmaker output) to a format readable by the
     * lifecycle manager. This includes translation of common terms to application specific settings.
     * The following rules apply when doing this translation:
     * - the translation is based on the transformations in the solutionsRegistry entry
     * - if a common term transforms into a setting which is already specific as application specific
     *      in the configuration argument, the application specific takes priority. In other words:
     *      if the configuration contains both an application specific and (transformable) common
     *       term for some application setting, the application specific one will stay and the
     *      transformed will be discarded.
     *
     * @param {Object} configuration - An element of the matchmaker output payload for a particular context
     *      (by the context manager).
     * @param {Object} solutionsRegistryEntries - A section of the solutions registry database, filtered for configured solutions (currently only done by OS and device context).
     * @return {Object} An object isomorphic to the "configuration" with settings blocks transformed and evaluated - this is ready to be
     * dispatched to settings handlers.
     */
    gpii.transformer.configurationToSettings = function (configuration, solutionsRegistryEntries) {
        var togo = fluid.transform(configuration.applications, function (oneUserSolution, solutionId) {
            var oneSolution = fluid.copy(solutionsRegistryEntries[solutionId]);
            if (oneSolution === undefined) {
                fluid.log("The configuration to be applied contains an entry for " + solutionId +
                    " which was not found in the solutionsRegistry. Aborting configuration");
                return undefined;
            }
            delete oneSolution.contexts; // solutions registry entries should include this as "old device reporter context info"
            oneSolution.settingsHandlers = fluid.transform(oneSolution.settingsHandlers, function (settingsHandler) {
                return gpii.transformer.transformOneSettingsHandler(settingsHandler, oneUserSolution, solutionId);
            });
            oneSolution.active = oneUserSolution.active; // copy over active directive for later use
            return oneSolution;
        });

        // ensure no empty entries exist in the settings payload
        for (var i in togo) {
            if (togo[i] === undefined) {
                delete togo[i];
            }
        }
        return togo;
    };

    // TODO: This transform has no tests
    fluid.defaults("gpii.transformer.booleanToNumber", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.booleanToNumber = function (value) {
        return value ? 1 : 0;
    };

    /**
     * timeInRange is implemented specifically for checking whether an input time falls in between
     * two given times. The valid and required inputs, besides the standard input/inputPath are `to`
     * and `from`. All inputs should be strings of the type "hh:mm" (eg. "17:30"). The range wraps
     * midnight, so given a `from` of "20:00" and a `to` of `"08:00"` all the following inputs would
     * result in true: "20:00", 23:00", "02:45".
     */
    fluid.defaults("gpii.transformer.timeInRange", {
        gradeNames: "fluid.standardTransformFunction"
    });


    gpii.transformer.timeInRange = function (value, transformSpec) {
        var timeInRange = gpii.transformer.timeInRange;
        var currentTime = timeInRange.timeParser(value);
        var fromTime = timeInRange.timeParser(transformSpec.from);
        var toTime = timeInRange.timeParser(transformSpec.to);

        if (timeInRange.isEarlier(toTime, fromTime)) { // if time wraps
            return (timeInRange.isEarlier(fromTime, currentTime) || timeInRange.isEarlier(currentTime, toTime));
        } else {
            return (timeInRange.isEarlier(fromTime, currentTime) && timeInRange.isEarlier(currentTime, toTime));
        }
    };

    gpii.transformer.timeInRange.timeParser = function (time) {
        time = time.split(":");
        return {
            hours: parseInt(time[0], 10),
            minutes: parseInt(time[1], 10)
        };
    };

    // checks whether 'first' is earlier than 'second' - returns true if so
    gpii.transformer.timeInRange.isEarlier = function (first, second) {
        return (60 * (first.hours - second.hours) + first.minutes - second.minutes) < 0;
    };

    /**
     * New transformation that lets you ignore a path if it's undefined, and supply another value instead.
     *
     * The input format for it should be the following:
     *
     * "transform": {
     *     "type": "fluid.transforms.fallbackValue",
     *     "inputPath": pathToValue,
     *     "outputPath": outputPathToStoreValue,
     *     "default": defaultValue
     * }
     *
     * Spec:
     *  - inputPath: The input path to test for nullity.
     *  - outputPath: The output path to put the result value from the transformation.
     *  - default: The default value to put in the "outputPath" in case of this being null.
     *
     * @param {Object} transformSpec Transformation specification.
     * @param {*} transformer The transformer for the transformation.
     * @return {Object} The output value resulting of the transformation.
     */
    fluid.transforms.fallbackValue = function (transformSpec, transformer) {
        if (transformSpec.defaultValue === undefined) {
            fluid.fail("fallbackValue requires an fallback value named \"default\", supplied ", transformSpec);
        }
        var value = fluid.model.transform.getValue(transformSpec.inputPath, transformSpec.defaultInput, transformer);

        transformer.outputPrefixOp.push(transformSpec.outputPath);

        var outputValue = undefined;
        if (value === undefined) {
            outputValue = transformSpec.defaultValue;
            if (typeof(transformSpec.outputPath) === "string" && outputValue !== undefined) {
                fluid.model.transform.setValue(undefined, outputValue, transformer, transformSpec.merge);
                outputValue = undefined;
            }
        } else {
            outputValue = value;
            if (typeof(transformSpec.outputPath) === "string" && outputValue !== undefined) {
                fluid.model.transform.setValue(undefined, outputValue, transformer, transformSpec.merge);
                outputValue = undefined;
            }
        }
        transformer.outputPrefixOp.pop();

        return outputValue;
    };

    fluid.transforms.fallbackValue.collect = function (transformSpec, transformer) {
        var togo = [];
        fluid.model.transform.accumulateStandardInputPath("defaultInput", transformSpec, transformer, togo);
        fluid.each(transformSpec.match, function (option) {
            fluid.model.transform.accumulateInputPath(option.inputPath, transformer, togo);
        });
        return togo;
    };

    fluid.defaults("fluid.transforms.fallbackValue", {
        gradeNames: ["fluid.transformFunction"]
    });
})();
