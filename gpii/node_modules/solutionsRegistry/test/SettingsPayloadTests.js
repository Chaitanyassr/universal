"use strict";
var fluid  = require("infusion");
var gpii   = fluid.registerNamespace("gpii");
var jqUnit = require("node-jqunit");

require("json5/lib/register");

var fs   = require("fs");
var path = require("path");

require("gpii-json-schema");

require("./lib/validation");

jqUnit.module("Sanity checks for test settings payloads.");

fluid.registerNamespace("gpii.tests.universal.solutionsRegistry.settingsPayloads");

gpii.tests.universal.solutionsRegistry.settingsPayloads.validateSettingsDir = function (that) {
    jqUnit.test("Validating preferences test data.", function () {
        var settingsIndex = gpii.tests.universal.solutionsRegistry.settingsPayloads.indexAllSettings(that);

        var resolvedPath = fluid.module.resolvePath(that.options.settingsDataPath);
        var pathFiles = fs.readdirSync(resolvedPath);
        var jsonFiles = pathFiles.filter(function (singlePath) { return singlePath.match(/.json5?$/i); });
        var pathedJsonFiles = fluid.transform(jsonFiles, function (jsonFile) {
            return path.resolve(resolvedPath, jsonFile);
        });
        fluid.each(pathedJsonFiles, function (settingsFilePath) {
            gpii.tests.universal.solutionsRegistry.settingsPayloads.validateSettingsFile(that, settingsFilePath, settingsIndex);
        });
    });
};

gpii.tests.universal.solutionsRegistry.settingsPayloads.validateSettingsFile = function (that, settingsFilePath, settingsIndex) {
    //var startTime = Date.now();
    var settingsSchema = require("../src/schemas/settings-base-schema.json5");

    var settingsData = {};
    try {
        settingsData = require(settingsFilePath);
    }
    catch (error) {
        jqUnit.fail("There should not be any invalid settings files (failed checking '" + settingsFilePath + "'.");
        fluid.log(error);
    }

    // Validate each file using a new "settings payload" schema.
    var settingsFileIsValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
        settingsData,
        settingsSchema,
        "settings file '" + settingsFilePath + "'"
    );
    jqUnit.assertTrue("The settings file itself should match the schema for all settings files.", settingsFileIsValid);

    var preferences = fluid.get(settingsData, ["flat", "contexts", "gpii-default", "preferences"]);
    var fileErrors = 0;
    fluid.each(preferences, function (preferencePayload, preferenceKey) {
        // "generic preference term", which are "shallow", i.e. a single value.
        if (preferenceKey.indexOf("http://registry.gpii.net/common/") === 0) {
            var settingsDefs = settingsIndex[preferenceKey];

            fluid.each(settingsDefs, function (settingsDef) {
                var isValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
                    preferencePayload,
                    settingsDef.schema,
                    "settings file " + settingsFilePath + " -> " + preferenceKey
                );

                if (!isValid) {
                    fileErrors++;
                }
            });
        }
        // "SR" preferences, which are "deep", i.e. multiple key:value pairs per solution.
        else {
            fluid.each(preferencePayload, function (prefValue, prefKey) {
                var solutionKey = preferenceKey.replace("http://registry.gpii.net/applications/", "");
                var settingsLabel = "settings file " + settingsFilePath + " -> " + solutionKey + " -> " + prefKey;
                var settingsDefs = fluid.get(settingsIndex, [solutionKey, prefKey]);

                if (!settingsDefs || settingsDefs.length === 0)  {
                    fluid.log("WARNING, setting found that does not correspond to a known setting: " + settingsLabel);
                }

                fluid.each(settingsDefs, function (settingsDef) {
                    if (settingsDef.schema) {
                        var isValid = gpii.tests.universal.solutionsRegistry.validateSinglePayload(
                            prefValue,
                            settingsDef.schema,
                            settingsLabel
                        );
                        if (!isValid) {
                            fileErrors++;
                        }
                    }
                });
            });
        }
    });
    jqUnit.assertEquals("There should be no validation errors in preferences file '" + settingsFilePath + "'.", 0, fileErrors);
    //fluid.log("Validated single file in " + (Date.now() - startTime) + " ms.")
};

/**
 *
 * A function to "index" all settings data across all OS-specific solutions as well as "generic preferences".  The
 * "index object" will be keyed by solution.  In the case of SR data, each entry will contain multiple settings
 * definitions, keyed by setting key. In the case of the "generic preferences", the "solution" will already be a single
 * setting definition.
 *
 * @param {Object} that - The test component itself, which has options for the locations of the required data.
 * @return {Object} An "index object" (see above).
 *
 */
gpii.tests.universal.solutionsRegistry.settingsPayloads.indexAllSettings = function (that) {
    var indexObject = {};
    var resolvedSrPath = fluid.module.resolvePath(that.options.solutionsRegistryPath);

    var srFiles = fs.readdirSync(resolvedSrPath);
    fluid.each(srFiles, function (filename) {
        if (filename.match(/^.+\.json5?$/i)) {
            var srFilePath = path.resolve(resolvedSrPath, filename);
            var srData = require(srFilePath);
            gpii.tests.universal.solutionsRegistry.settingsPayloads.indexSrEntries(indexObject, srData);
        }
    });
    var genericTermsPath = fluid.module.resolvePath(that.options.genericPreferenceTermsPath);
    var genericTermsData = require(genericTermsPath);

    gpii.tests.universal.solutionsRegistry.settingsPayloads.indexGenericPreferences(indexObject, genericTermsData);

    return indexObject;
};

gpii.tests.universal.solutionsRegistry.settingsPayloads.indexGenericPreferences = function (indexObject, genericTermsData) {
    fluid.each(genericTermsData, function (settingDef, settingKey) {
        gpii.tests.universal.solutionsRegistry.settingsPayloads.indexSingleSolution(indexObject, [settingKey], settingDef);
    });
};

gpii.tests.universal.solutionsRegistry.settingsPayloads.indexSrEntries = function (indexObject, srData) {
    fluid.each(srData, function (solutionDef, solutionKey) {
        fluid.each(solutionDef.settingsHandlers, function (settingsHandler) {
            fluid.each(settingsHandler.supportedSettings, function (settingDef, settingKey) {
                gpii.tests.universal.solutionsRegistry.settingsPayloads.indexSingleSolution(indexObject, [solutionKey, settingKey], settingDef);
            });
        });
    });
};

gpii.tests.universal.solutionsRegistry.settingsPayloads.indexSingleSolution = function (indexObject, pathToSetting, settingDef) {
    var existingEntry = fluid.get(indexObject, pathToSetting);
    if (existingEntry) {
        existingEntry.push(settingDef);
    }
    else {
        fluid.set(indexObject, pathToSetting, [settingDef]);
    }
};

fluid.defaults("gpii.tests.universal.solutionsRegistry.settingsPayloads", {
    gradeNames: ["fluid.component"],
    solutionsRegistryPath: "%gpii-universal/testData/solutions",
    genericPreferenceTermsPath: "%gpii-universal/testData/ontologies/flat.json5",
    settingsDataPath: "%gpii-universal/testData/preferences",
    listeners: {
        "onCreate.validateSettingsDir": {
            funcName: "gpii.tests.universal.solutionsRegistry.settingsPayloads.validateSettingsDir",
            args: ["{that}"]
        }
    }
});

gpii.tests.universal.solutionsRegistry.settingsPayloads();
