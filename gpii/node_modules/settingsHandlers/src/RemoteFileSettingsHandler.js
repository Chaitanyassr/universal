/* Remote file settings handler.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var path = require("path"),
    request = require("request"),
    fs = require("fs"),
    crypto = require("crypto"),
    fluid = require("infusion"),
    mkdirp = require("mkdirp"),
    gpii = fluid.registerNamespace("gpii");


var remoteFileSettingsHandler = fluid.registerNamespace("gpii.settingsHandlers.remoteFileSettingsHandler");


/**
 * Returns a function which can be used as a callback to asynchronous functions, which will resolve or reject
 * the given promise based on the existence of the single parameter.
 *
 * In other words, if the async function fails, the promise will reject (with the error passed to the callback),
 * otherwise the promise will resolve with the given value.
 *
 * @param {Promise} promise The promise to reject or resolve.
 * @param {Object} value [optional] The value with which the promise is resolved.
 * @return {Function} A callback function that can be used for standard async functions.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.callbackToPromise = function (promise, value) {
    return function (err) {
        if (err) {
            promise.reject(err);
        } else {
            promise.resolve(value);
        }
    };
};

/**
 * Gets the path of a temporary file, in the given subdirectory of the GPII settings directory, which will be used
 * to download a file or take a copy of an existing file.
 *
 * The filename is based on the source of the file (the url or original path).
 *
 * @param {String} directory The subdirectory in the GPII settings directory.
 * @param {String} sourcePath A string that identifies the file origin (eg, the source url/path)
 * @return {String} The path of a temporary file.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.getTempFilename = function (directory, sourcePath) {
    if (!remoteFileSettingsHandler.settingsDir) {
        var settingsDirComponent = gpii.settingsDir();
        remoteFileSettingsHandler.settingsDir = settingsDirComponent.getGpiiSettingsDir();
        settingsDirComponent.destroy();
    }

    var sha1 = crypto.createHash("sha1");
    sha1.update(sourcePath);
    var filename = sha1.digest("hex");

    var childPath = path.join(remoteFileSettingsHandler.settingsDir, directory);
    mkdirp.sync(childPath);

    return path.join(childPath, filename);
};

/**
 * Downloads a file
 * @param {String} url The remote file location.
 * @return {Promise} Resolves, with the path of the new file.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.downloadFile = function (url) {
    var promise = fluid.promise();

    // Get the destination filename.
    var destinationFile = remoteFileSettingsHandler.getTempFilename("downloads", url);
    // The intermediate filename (named differently to signify the download is incomplete).
    var tempFile = destinationFile + ".downloading";
    var outStream;

    fluid.log("remoteFileSettingsHandler: Downloading " + url + " to " + destinationFile);

    // Always close the output stream after an error.
    promise.then(null, function () {
        if (outStream) {
            outStream.close();
        }
    });

    var req = request.get({
        uri: url
    });

    req.on("error", promise.reject);

    req.on("response", function (response) {
        if (response.statusCode === 200) {
            outStream = fs.createWriteStream(tempFile);
            response.pipe(outStream);
            response.on("end", function () {
                outStream.close();
                outStream = null;
                fs.rename(tempFile, destinationFile,
                    remoteFileSettingsHandler.callbackToPromise(promise, destinationFile));
            });
        } else {
            promise.reject({
                isError: true,
                message: "Unable to download " + url + ": " + response.statusCode
            });
        }
    });

    return promise;
};

/**
 * Applies the file change, by copying the new file into the destination. If there's already a file in the destination
 * path, it will be stashed so it can be reverted later.
 *
 * @param {String} source Path to the new file.
 * @param {String} destination Path to where the new file should be placed.
 * @param {Boolean} keepSource true if the source file needs to be kept.
 * @return {Promise} Resolves with the path to where the original file has been moved (or null if it did not exist).
 */
gpii.settingsHandlers.remoteFileSettingsHandler.applyFile = function (source, destination, keepSource) {
    var promise = fluid.promise();

    fluid.log("remoteFileSettingsHandler: Applying '" + source + "' to '" + destination + "'");

    var stashPromise = fluid.promise();
    if (fs.existsSync(destination)) {
        // Move the original file out of the way.
        var stashedFile = remoteFileSettingsHandler.getTempFilename("stashed", destination);
        fs.rename(destination, stashedFile, remoteFileSettingsHandler.callbackToPromise(stashPromise, stashedFile));
    } else {
        // Make sure the destination directory exists.
        mkdirp(path.dirname(destination), remoteFileSettingsHandler.callbackToPromise(stashPromise));
    }

    // Copy/move the source file into the destination.
    stashPromise.then(function (stashedFile) {
        var action = keepSource ? fs.copyFile : fs.rename;
        action(source, destination, remoteFileSettingsHandler.callbackToPromise(promise, stashedFile));
    });

    return promise;
};

/**
 * Setter for the remote file settings handler.
 *
 * {
 *  "settings": {
 *    "word-ribbon": "file1"
 *  },
 *  "options": {
 *    "settings": {
 *      "word-ribbon": {
 *        "path": "c:\\ ...",
 *        "url": "https://example.com/"
 *      },
 *      "excel-ribbon": {
 *        "path": "c:\\ ...",
 *        "url": "https://example.com/"
 *      }
 *    }
 *  }
 * }
 *
 * @param {Object} payload The payload.
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.setImpl = function (payload) {
    var promiseTogo = fluid.promise();

    var results = {};
    var promises = [];
    fluid.each(payload.settings, function (value, key) {

        if (value) {
            var settingPromise = fluid.promise();
            promises.push(settingPromise);
            settingPromise.then(null, function (reason) {
                fluid.fail("removeFileSettingsHandler failed for setting '" + key + "' in payload ", payload, reason);
            });

            var options = payload.options.settings[key];

            if (value.hasOwnProperty("restore")) {
                // The file is being restored, move it back from the stashed location.
                if (value.restore) {
                    fs.rename(value.restore, options.path, remoteFileSettingsHandler.callbackToPromise(settingPromise));
                } else {
                    fs.unlink(options.path, remoteFileSettingsHandler.callbackToPromise(settingPromise));
                }
            } else {
                // Build the URL.
                var url = fluid.stringTemplate(options.url, {
                    value: encodeURIComponent(value)
                });

                // Download the file.
                remoteFileSettingsHandler.downloadFile(url).then(function (downloadedFile) {
                    // Copy it to the destination.
                    remoteFileSettingsHandler.applyFile(downloadedFile, options.path, options.cache).then(function (stashedFile) {
                        results[key] = {
                            oldValue: {
                                restore: stashedFile || null
                            },
                            newValue: {
                                value: options.path
                            }
                        };
                        settingPromise.resolve();
                    }, settingPromise.reject);
                }, settingPromise.reject);
            }
        }
    });

    // Resolve the return promise when the files have been processed.
    fluid.promise.sequence(promises).then(function () {
        promiseTogo.resolve(results);
    });

    return promiseTogo;
};

/**
 * Getter for the remote file settings handler.
 *
 * @param {Object} payload The payload.
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.getImpl = function (payload) {
    return remoteFileSettingsHandler.invokeHandler(true, payload);
};

/**
 * Invoke the settings handler.
 *
 * @param {Object} payload The payload
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.get = function (payload) {
    fluid.log("xyz get");
    return gpii.settingsHandlers.invokeSettingsHandler(remoteFileSettingsHandler.getImpl, payload);
};

/**
 * Invoke the settings handler.
 *
 * @param {Object} payload The payload
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.set = function (payload) {
    fluid.log("xyz set");
    return gpii.settingsHandlers.invokeSettingsHandler(remoteFileSettingsHandler.setImpl, payload);
};
